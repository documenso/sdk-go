// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/documenso/sdk-go/internal/utils"
	"github.com/documenso/sdk-go/models/components"
)

// DocumentUpdateVisibilityRequest - The visibility of the document.
type DocumentUpdateVisibilityRequest string

const (
	DocumentUpdateVisibilityRequestEveryone        DocumentUpdateVisibilityRequest = "EVERYONE"
	DocumentUpdateVisibilityRequestManagerAndAbove DocumentUpdateVisibilityRequest = "MANAGER_AND_ABOVE"
	DocumentUpdateVisibilityRequestAdmin           DocumentUpdateVisibilityRequest = "ADMIN"
)

func (e DocumentUpdateVisibilityRequest) ToPointer() *DocumentUpdateVisibilityRequest {
	return &e
}
func (e *DocumentUpdateVisibilityRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EVERYONE":
		fallthrough
	case "MANAGER_AND_ABOVE":
		fallthrough
	case "ADMIN":
		*e = DocumentUpdateVisibilityRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateVisibilityRequest: %v", v)
	}
}

// DocumentUpdateGlobalAccessAuthRequest - The type of authentication required for the recipient to access the document.
type DocumentUpdateGlobalAccessAuthRequest string

const (
	DocumentUpdateGlobalAccessAuthRequestAccount       DocumentUpdateGlobalAccessAuthRequest = "ACCOUNT"
	DocumentUpdateGlobalAccessAuthRequestTwoFactorAuth DocumentUpdateGlobalAccessAuthRequest = "TWO_FACTOR_AUTH"
)

func (e DocumentUpdateGlobalAccessAuthRequest) ToPointer() *DocumentUpdateGlobalAccessAuthRequest {
	return &e
}
func (e *DocumentUpdateGlobalAccessAuthRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "TWO_FACTOR_AUTH":
		*e = DocumentUpdateGlobalAccessAuthRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateGlobalAccessAuthRequest: %v", v)
	}
}

// DocumentUpdateGlobalActionAuthRequest - The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
type DocumentUpdateGlobalActionAuthRequest string

const (
	DocumentUpdateGlobalActionAuthRequestAccount       DocumentUpdateGlobalActionAuthRequest = "ACCOUNT"
	DocumentUpdateGlobalActionAuthRequestPasskey       DocumentUpdateGlobalActionAuthRequest = "PASSKEY"
	DocumentUpdateGlobalActionAuthRequestTwoFactorAuth DocumentUpdateGlobalActionAuthRequest = "TWO_FACTOR_AUTH"
	DocumentUpdateGlobalActionAuthRequestPassword      DocumentUpdateGlobalActionAuthRequest = "PASSWORD"
)

func (e DocumentUpdateGlobalActionAuthRequest) ToPointer() *DocumentUpdateGlobalActionAuthRequest {
	return &e
}
func (e *DocumentUpdateGlobalActionAuthRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		fallthrough
	case "PASSWORD":
		*e = DocumentUpdateGlobalActionAuthRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateGlobalActionAuthRequest: %v", v)
	}
}

type DocumentUpdateData struct {
	// The title of the document.
	Title *string `json:"title,omitempty"`
	// The external ID of the document.
	ExternalID *string `json:"externalId,omitempty"`
	// The visibility of the document.
	Visibility              *DocumentUpdateVisibilityRequest        `json:"visibility,omitempty"`
	GlobalAccessAuth        []DocumentUpdateGlobalAccessAuthRequest `json:"globalAccessAuth,omitempty"`
	GlobalActionAuth        []DocumentUpdateGlobalActionAuthRequest `json:"globalActionAuth,omitempty"`
	UseLegacyFieldInsertion *bool                                   `json:"useLegacyFieldInsertion,omitempty"`
	FolderID                *string                                 `json:"folderId,omitempty"`
}

func (d *DocumentUpdateData) GetTitle() *string {
	if d == nil {
		return nil
	}
	return d.Title
}

func (d *DocumentUpdateData) GetExternalID() *string {
	if d == nil {
		return nil
	}
	return d.ExternalID
}

func (d *DocumentUpdateData) GetVisibility() *DocumentUpdateVisibilityRequest {
	if d == nil {
		return nil
	}
	return d.Visibility
}

func (d *DocumentUpdateData) GetGlobalAccessAuth() []DocumentUpdateGlobalAccessAuthRequest {
	if d == nil {
		return nil
	}
	return d.GlobalAccessAuth
}

func (d *DocumentUpdateData) GetGlobalActionAuth() []DocumentUpdateGlobalActionAuthRequest {
	if d == nil {
		return nil
	}
	return d.GlobalActionAuth
}

func (d *DocumentUpdateData) GetUseLegacyFieldInsertion() *bool {
	if d == nil {
		return nil
	}
	return d.UseLegacyFieldInsertion
}

func (d *DocumentUpdateData) GetFolderID() *string {
	if d == nil {
		return nil
	}
	return d.FolderID
}

// DocumentUpdateDateFormat - The date format to use for date fields and signing the document.
type DocumentUpdateDateFormat string

const (
	DocumentUpdateDateFormatYyyyMMddHhMmA            DocumentUpdateDateFormat = "yyyy-MM-dd hh:mm a"
	DocumentUpdateDateFormatYyyyMMdd                 DocumentUpdateDateFormat = "yyyy-MM-dd"
	DocumentUpdateDateFormatDdMmSlashYyyy            DocumentUpdateDateFormat = "dd/MM/yyyy"
	DocumentUpdateDateFormatMmDdSlashYyyy            DocumentUpdateDateFormat = "MM/dd/yyyy"
	DocumentUpdateDateFormatYyMMdd                   DocumentUpdateDateFormat = "yy-MM-dd"
	DocumentUpdateDateFormatMmmmDdCommaYyyy          DocumentUpdateDateFormat = "MMMM dd, yyyy"
	DocumentUpdateDateFormatEeeeMmmmDdCommaYyyy      DocumentUpdateDateFormat = "EEEE, MMMM dd, yyyy"
	DocumentUpdateDateFormatDdMmSlashYyyyHhMmA       DocumentUpdateDateFormat = "dd/MM/yyyy hh:mm a"
	DocumentUpdateDateFormatDdMmSlashYyyyHHmm        DocumentUpdateDateFormat = "dd/MM/yyyy HH:mm"
	DocumentUpdateDateFormatMmDdSlashYyyyHhMmA       DocumentUpdateDateFormat = "MM/dd/yyyy hh:mm a"
	DocumentUpdateDateFormatMmDdSlashYyyyHHmm        DocumentUpdateDateFormat = "MM/dd/yyyy HH:mm"
	DocumentUpdateDateFormatDdDotMmDotYyyy           DocumentUpdateDateFormat = "dd.MM.yyyy"
	DocumentUpdateDateFormatDdDotMmDotYyyyHHmm       DocumentUpdateDateFormat = "dd.MM.yyyy HH:mm"
	DocumentUpdateDateFormatYyyyMMddHHmm             DocumentUpdateDateFormat = "yyyy-MM-dd HH:mm"
	DocumentUpdateDateFormatYyMMddHhMmA              DocumentUpdateDateFormat = "yy-MM-dd hh:mm a"
	DocumentUpdateDateFormatYyMMddHHmm               DocumentUpdateDateFormat = "yy-MM-dd HH:mm"
	DocumentUpdateDateFormatYyyyMMddHHmmss           DocumentUpdateDateFormat = "yyyy-MM-dd HH:mm:ss"
	DocumentUpdateDateFormatMmmmDdCommaYyyyHhMmA     DocumentUpdateDateFormat = "MMMM dd, yyyy hh:mm a"
	DocumentUpdateDateFormatMmmmDdCommaYyyyHHmm      DocumentUpdateDateFormat = "MMMM dd, yyyy HH:mm"
	DocumentUpdateDateFormatEeeeMmmmDdCommaYyyyHhMmA DocumentUpdateDateFormat = "EEEE, MMMM dd, yyyy hh:mm a"
	DocumentUpdateDateFormatEeeeMmmmDdCommaYyyyHHmm  DocumentUpdateDateFormat = "EEEE, MMMM dd, yyyy HH:mm"
	DocumentUpdateDateFormatIso8601Full              DocumentUpdateDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
)

func (e DocumentUpdateDateFormat) ToPointer() *DocumentUpdateDateFormat {
	return &e
}
func (e *DocumentUpdateDateFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "yyyy-MM-dd hh:mm a":
		fallthrough
	case "yyyy-MM-dd":
		fallthrough
	case "dd/MM/yyyy":
		fallthrough
	case "MM/dd/yyyy":
		fallthrough
	case "yy-MM-dd":
		fallthrough
	case "MMMM dd, yyyy":
		fallthrough
	case "EEEE, MMMM dd, yyyy":
		fallthrough
	case "dd/MM/yyyy hh:mm a":
		fallthrough
	case "dd/MM/yyyy HH:mm":
		fallthrough
	case "MM/dd/yyyy hh:mm a":
		fallthrough
	case "MM/dd/yyyy HH:mm":
		fallthrough
	case "dd.MM.yyyy":
		fallthrough
	case "dd.MM.yyyy HH:mm":
		fallthrough
	case "yyyy-MM-dd HH:mm":
		fallthrough
	case "yy-MM-dd hh:mm a":
		fallthrough
	case "yy-MM-dd HH:mm":
		fallthrough
	case "yyyy-MM-dd HH:mm:ss":
		fallthrough
	case "MMMM dd, yyyy hh:mm a":
		fallthrough
	case "MMMM dd, yyyy HH:mm":
		fallthrough
	case "EEEE, MMMM dd, yyyy hh:mm a":
		fallthrough
	case "EEEE, MMMM dd, yyyy HH:mm":
		fallthrough
	case "yyyy-MM-dd'T'HH:mm:ss.SSSXXX":
		*e = DocumentUpdateDateFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateDateFormat: %v", v)
	}
}

// DocumentUpdateDistributionMethod - The distribution method to use when sending the document to the recipients.
type DocumentUpdateDistributionMethod string

const (
	DocumentUpdateDistributionMethodEmail DocumentUpdateDistributionMethod = "EMAIL"
	DocumentUpdateDistributionMethodNone  DocumentUpdateDistributionMethod = "NONE"
)

func (e DocumentUpdateDistributionMethod) ToPointer() *DocumentUpdateDistributionMethod {
	return &e
}
func (e *DocumentUpdateDistributionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EMAIL":
		fallthrough
	case "NONE":
		*e = DocumentUpdateDistributionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateDistributionMethod: %v", v)
	}
}

type DocumentUpdateSigningOrder string

const (
	DocumentUpdateSigningOrderParallel   DocumentUpdateSigningOrder = "PARALLEL"
	DocumentUpdateSigningOrderSequential DocumentUpdateSigningOrder = "SEQUENTIAL"
)

func (e DocumentUpdateSigningOrder) ToPointer() *DocumentUpdateSigningOrder {
	return &e
}
func (e *DocumentUpdateSigningOrder) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PARALLEL":
		fallthrough
	case "SEQUENTIAL":
		*e = DocumentUpdateSigningOrder(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateSigningOrder: %v", v)
	}
}

// DocumentUpdateLanguage - The language to use for email communications with recipients.
type DocumentUpdateLanguage string

const (
	DocumentUpdateLanguageDe DocumentUpdateLanguage = "de"
	DocumentUpdateLanguageEn DocumentUpdateLanguage = "en"
	DocumentUpdateLanguageFr DocumentUpdateLanguage = "fr"
	DocumentUpdateLanguageEs DocumentUpdateLanguage = "es"
	DocumentUpdateLanguageIt DocumentUpdateLanguage = "it"
	DocumentUpdateLanguagePl DocumentUpdateLanguage = "pl"
)

func (e DocumentUpdateLanguage) ToPointer() *DocumentUpdateLanguage {
	return &e
}
func (e *DocumentUpdateLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "de":
		fallthrough
	case "en":
		fallthrough
	case "fr":
		fallthrough
	case "es":
		fallthrough
	case "it":
		fallthrough
	case "pl":
		*e = DocumentUpdateLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateLanguage: %v", v)
	}
}

type DocumentUpdateEmailSettings struct {
	// Whether to send an email to all recipients that the document is ready for them to sign.
	RecipientSigningRequest *bool `default:"true" json:"recipientSigningRequest"`
	// Whether to send an email to the recipient who was removed from a pending document.
	RecipientRemoved *bool `default:"true" json:"recipientRemoved"`
	// Whether to send an email to the document owner when a recipient has signed the document.
	RecipientSigned *bool `default:"true" json:"recipientSigned"`
	// Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed.
	DocumentPending *bool `default:"true" json:"documentPending"`
	// Whether to send an email to all recipients when the document is complete.
	DocumentCompleted *bool `default:"true" json:"documentCompleted"`
	// Whether to send an email to all recipients if a pending document has been deleted.
	DocumentDeleted *bool `default:"true" json:"documentDeleted"`
	// Whether to send an email to the document owner when the document is complete.
	OwnerDocumentCompleted *bool `default:"true" json:"ownerDocumentCompleted"`
}

func (d DocumentUpdateEmailSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DocumentUpdateEmailSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (d *DocumentUpdateEmailSettings) GetRecipientSigningRequest() *bool {
	if d == nil {
		return nil
	}
	return d.RecipientSigningRequest
}

func (d *DocumentUpdateEmailSettings) GetRecipientRemoved() *bool {
	if d == nil {
		return nil
	}
	return d.RecipientRemoved
}

func (d *DocumentUpdateEmailSettings) GetRecipientSigned() *bool {
	if d == nil {
		return nil
	}
	return d.RecipientSigned
}

func (d *DocumentUpdateEmailSettings) GetDocumentPending() *bool {
	if d == nil {
		return nil
	}
	return d.DocumentPending
}

func (d *DocumentUpdateEmailSettings) GetDocumentCompleted() *bool {
	if d == nil {
		return nil
	}
	return d.DocumentCompleted
}

func (d *DocumentUpdateEmailSettings) GetDocumentDeleted() *bool {
	if d == nil {
		return nil
	}
	return d.DocumentDeleted
}

func (d *DocumentUpdateEmailSettings) GetOwnerDocumentCompleted() *bool {
	if d == nil {
		return nil
	}
	return d.OwnerDocumentCompleted
}

type DocumentUpdateMeta struct {
	// The subject of the email that will be sent to the recipients.
	Subject *string `json:"subject,omitempty"`
	// The message of the email that will be sent to the recipients.
	Message *string `json:"message,omitempty"`
	// The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne
	Timezone *string `json:"timezone,omitempty"`
	// The date format to use for date fields and signing the document.
	DateFormat *DocumentUpdateDateFormat `json:"dateFormat,omitempty"`
	// The distribution method to use when sending the document to the recipients.
	DistributionMethod     *DocumentUpdateDistributionMethod `json:"distributionMethod,omitempty"`
	SigningOrder           *DocumentUpdateSigningOrder       `json:"signingOrder,omitempty"`
	AllowDictateNextSigner *bool                             `json:"allowDictateNextSigner,omitempty"`
	// The URL to which the recipient should be redirected after signing the document.
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// The language to use for email communications with recipients.
	Language *DocumentUpdateLanguage `json:"language,omitempty"`
	// Whether to allow recipients to sign using a typed signature.
	TypedSignatureEnabled *bool `json:"typedSignatureEnabled,omitempty"`
	// Whether to allow recipients to sign using an uploaded signature.
	UploadSignatureEnabled *bool `json:"uploadSignatureEnabled,omitempty"`
	// Whether to allow recipients to sign using a draw signature.
	DrawSignatureEnabled *bool                        `json:"drawSignatureEnabled,omitempty"`
	EmailID              *string                      `json:"emailId,omitempty"`
	EmailReplyTo         *string                      `json:"emailReplyTo,omitempty"`
	EmailSettings        *DocumentUpdateEmailSettings `json:"emailSettings,omitempty"`
}

func (d *DocumentUpdateMeta) GetSubject() *string {
	if d == nil {
		return nil
	}
	return d.Subject
}

func (d *DocumentUpdateMeta) GetMessage() *string {
	if d == nil {
		return nil
	}
	return d.Message
}

func (d *DocumentUpdateMeta) GetTimezone() *string {
	if d == nil {
		return nil
	}
	return d.Timezone
}

func (d *DocumentUpdateMeta) GetDateFormat() *DocumentUpdateDateFormat {
	if d == nil {
		return nil
	}
	return d.DateFormat
}

func (d *DocumentUpdateMeta) GetDistributionMethod() *DocumentUpdateDistributionMethod {
	if d == nil {
		return nil
	}
	return d.DistributionMethod
}

func (d *DocumentUpdateMeta) GetSigningOrder() *DocumentUpdateSigningOrder {
	if d == nil {
		return nil
	}
	return d.SigningOrder
}

func (d *DocumentUpdateMeta) GetAllowDictateNextSigner() *bool {
	if d == nil {
		return nil
	}
	return d.AllowDictateNextSigner
}

func (d *DocumentUpdateMeta) GetRedirectURL() *string {
	if d == nil {
		return nil
	}
	return d.RedirectURL
}

func (d *DocumentUpdateMeta) GetLanguage() *DocumentUpdateLanguage {
	if d == nil {
		return nil
	}
	return d.Language
}

func (d *DocumentUpdateMeta) GetTypedSignatureEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.TypedSignatureEnabled
}

func (d *DocumentUpdateMeta) GetUploadSignatureEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.UploadSignatureEnabled
}

func (d *DocumentUpdateMeta) GetDrawSignatureEnabled() *bool {
	if d == nil {
		return nil
	}
	return d.DrawSignatureEnabled
}

func (d *DocumentUpdateMeta) GetEmailID() *string {
	if d == nil {
		return nil
	}
	return d.EmailID
}

func (d *DocumentUpdateMeta) GetEmailReplyTo() *string {
	if d == nil {
		return nil
	}
	return d.EmailReplyTo
}

func (d *DocumentUpdateMeta) GetEmailSettings() *DocumentUpdateEmailSettings {
	if d == nil {
		return nil
	}
	return d.EmailSettings
}

type DocumentUpdateRequest struct {
	DocumentID float64             `json:"documentId"`
	Data       *DocumentUpdateData `json:"data,omitempty"`
	Meta       *DocumentUpdateMeta `json:"meta,omitempty"`
}

func (d *DocumentUpdateRequest) GetDocumentID() float64 {
	if d == nil {
		return 0.0
	}
	return d.DocumentID
}

func (d *DocumentUpdateRequest) GetData() *DocumentUpdateData {
	if d == nil {
		return nil
	}
	return d.Data
}

func (d *DocumentUpdateRequest) GetMeta() *DocumentUpdateMeta {
	if d == nil {
		return nil
	}
	return d.Meta
}

type DocumentUpdateVisibilityResponse string

const (
	DocumentUpdateVisibilityResponseEveryone        DocumentUpdateVisibilityResponse = "EVERYONE"
	DocumentUpdateVisibilityResponseManagerAndAbove DocumentUpdateVisibilityResponse = "MANAGER_AND_ABOVE"
	DocumentUpdateVisibilityResponseAdmin           DocumentUpdateVisibilityResponse = "ADMIN"
)

func (e DocumentUpdateVisibilityResponse) ToPointer() *DocumentUpdateVisibilityResponse {
	return &e
}
func (e *DocumentUpdateVisibilityResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EVERYONE":
		fallthrough
	case "MANAGER_AND_ABOVE":
		fallthrough
	case "ADMIN":
		*e = DocumentUpdateVisibilityResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateVisibilityResponse: %v", v)
	}
}

type DocumentUpdateStatus string

const (
	DocumentUpdateStatusDraft     DocumentUpdateStatus = "DRAFT"
	DocumentUpdateStatusPending   DocumentUpdateStatus = "PENDING"
	DocumentUpdateStatusCompleted DocumentUpdateStatus = "COMPLETED"
	DocumentUpdateStatusRejected  DocumentUpdateStatus = "REJECTED"
)

func (e DocumentUpdateStatus) ToPointer() *DocumentUpdateStatus {
	return &e
}
func (e *DocumentUpdateStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DRAFT":
		fallthrough
	case "PENDING":
		fallthrough
	case "COMPLETED":
		fallthrough
	case "REJECTED":
		*e = DocumentUpdateStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateStatus: %v", v)
	}
}

type DocumentUpdateSource string

const (
	DocumentUpdateSourceDocument           DocumentUpdateSource = "DOCUMENT"
	DocumentUpdateSourceTemplate           DocumentUpdateSource = "TEMPLATE"
	DocumentUpdateSourceTemplateDirectLink DocumentUpdateSource = "TEMPLATE_DIRECT_LINK"
)

func (e DocumentUpdateSource) ToPointer() *DocumentUpdateSource {
	return &e
}
func (e *DocumentUpdateSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DOCUMENT":
		fallthrough
	case "TEMPLATE":
		fallthrough
	case "TEMPLATE_DIRECT_LINK":
		*e = DocumentUpdateSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateSource: %v", v)
	}
}

// DocumentUpdateGlobalAccessAuthResponse - The type of authentication required for the recipient to access the document.
type DocumentUpdateGlobalAccessAuthResponse string

const (
	DocumentUpdateGlobalAccessAuthResponseAccount       DocumentUpdateGlobalAccessAuthResponse = "ACCOUNT"
	DocumentUpdateGlobalAccessAuthResponseTwoFactorAuth DocumentUpdateGlobalAccessAuthResponse = "TWO_FACTOR_AUTH"
)

func (e DocumentUpdateGlobalAccessAuthResponse) ToPointer() *DocumentUpdateGlobalAccessAuthResponse {
	return &e
}
func (e *DocumentUpdateGlobalAccessAuthResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "TWO_FACTOR_AUTH":
		*e = DocumentUpdateGlobalAccessAuthResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateGlobalAccessAuthResponse: %v", v)
	}
}

// DocumentUpdateGlobalActionAuthResponse - The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
type DocumentUpdateGlobalActionAuthResponse string

const (
	DocumentUpdateGlobalActionAuthResponseAccount       DocumentUpdateGlobalActionAuthResponse = "ACCOUNT"
	DocumentUpdateGlobalActionAuthResponsePasskey       DocumentUpdateGlobalActionAuthResponse = "PASSKEY"
	DocumentUpdateGlobalActionAuthResponseTwoFactorAuth DocumentUpdateGlobalActionAuthResponse = "TWO_FACTOR_AUTH"
	DocumentUpdateGlobalActionAuthResponsePassword      DocumentUpdateGlobalActionAuthResponse = "PASSWORD"
)

func (e DocumentUpdateGlobalActionAuthResponse) ToPointer() *DocumentUpdateGlobalActionAuthResponse {
	return &e
}
func (e *DocumentUpdateGlobalActionAuthResponse) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		fallthrough
	case "PASSWORD":
		*e = DocumentUpdateGlobalActionAuthResponse(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentUpdateGlobalActionAuthResponse: %v", v)
	}
}

type DocumentUpdateAuthOptions struct {
	GlobalAccessAuth []DocumentUpdateGlobalAccessAuthResponse `json:"globalAccessAuth"`
	GlobalActionAuth []DocumentUpdateGlobalActionAuthResponse `json:"globalActionAuth"`
}

func (d *DocumentUpdateAuthOptions) GetGlobalAccessAuth() []DocumentUpdateGlobalAccessAuthResponse {
	if d == nil {
		return []DocumentUpdateGlobalAccessAuthResponse{}
	}
	return d.GlobalAccessAuth
}

func (d *DocumentUpdateAuthOptions) GetGlobalActionAuth() []DocumentUpdateGlobalActionAuthResponse {
	if d == nil {
		return []DocumentUpdateGlobalActionAuthResponse{}
	}
	return d.GlobalActionAuth
}

type DocumentUpdateFormValuesType string

const (
	DocumentUpdateFormValuesTypeStr     DocumentUpdateFormValuesType = "str"
	DocumentUpdateFormValuesTypeBoolean DocumentUpdateFormValuesType = "boolean"
	DocumentUpdateFormValuesTypeNumber  DocumentUpdateFormValuesType = "number"
)

type DocumentUpdateFormValues struct {
	Str     *string  `queryParam:"inline,name=formValues"`
	Boolean *bool    `queryParam:"inline,name=formValues"`
	Number  *float64 `queryParam:"inline,name=formValues"`

	Type DocumentUpdateFormValuesType
}

func CreateDocumentUpdateFormValuesStr(str string) DocumentUpdateFormValues {
	typ := DocumentUpdateFormValuesTypeStr

	return DocumentUpdateFormValues{
		Str:  &str,
		Type: typ,
	}
}

func CreateDocumentUpdateFormValuesBoolean(boolean bool) DocumentUpdateFormValues {
	typ := DocumentUpdateFormValuesTypeBoolean

	return DocumentUpdateFormValues{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateDocumentUpdateFormValuesNumber(number float64) DocumentUpdateFormValues {
	typ := DocumentUpdateFormValuesTypeNumber

	return DocumentUpdateFormValues{
		Number: &number,
		Type:   typ,
	}
}

func (u *DocumentUpdateFormValues) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = DocumentUpdateFormValuesTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = DocumentUpdateFormValuesTypeBoolean
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = DocumentUpdateFormValuesTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DocumentUpdateFormValues", string(data))
}

func (u DocumentUpdateFormValues) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type DocumentUpdateFormValues: all fields are null")
}

// DocumentUpdateResponseBody - Successful response
type DocumentUpdateResponseBody struct {
	Visibility DocumentUpdateVisibilityResponse `json:"visibility"`
	Status     DocumentUpdateStatus             `json:"status"`
	Source     DocumentUpdateSource             `json:"source"`
	ID         float64                          `json:"id"`
	// A custom external ID you can use to identify the document.
	ExternalID *string `json:"externalId"`
	// The ID of the user that created this document.
	UserID                  float64                             `json:"userId"`
	AuthOptions             *DocumentUpdateAuthOptions          `json:"authOptions"`
	FormValues              map[string]DocumentUpdateFormValues `json:"formValues"`
	Title                   string                              `json:"title"`
	CreatedAt               string                              `json:"createdAt"`
	UpdatedAt               string                              `json:"updatedAt"`
	CompletedAt             *string                             `json:"completedAt"`
	DeletedAt               *string                             `json:"deletedAt"`
	TeamID                  float64                             `json:"teamId"`
	FolderID                *string                             `json:"folderId"`
	UseLegacyFieldInsertion bool                                `json:"useLegacyFieldInsertion"`
	EnvelopeID              string                              `json:"envelopeId"`
	DocumentDataID          *string                             `default:"" json:"documentDataId"`
	// The ID of the template that the document was created from, if any.
	TemplateID *float64 `json:"templateId,omitempty"`
}

func (d DocumentUpdateResponseBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DocumentUpdateResponseBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"visibility", "status", "source", "id", "userId", "title", "createdAt", "updatedAt", "teamId", "useLegacyFieldInsertion", "envelopeId"}); err != nil {
		return err
	}
	return nil
}

func (d *DocumentUpdateResponseBody) GetVisibility() DocumentUpdateVisibilityResponse {
	if d == nil {
		return DocumentUpdateVisibilityResponse("")
	}
	return d.Visibility
}

func (d *DocumentUpdateResponseBody) GetStatus() DocumentUpdateStatus {
	if d == nil {
		return DocumentUpdateStatus("")
	}
	return d.Status
}

func (d *DocumentUpdateResponseBody) GetSource() DocumentUpdateSource {
	if d == nil {
		return DocumentUpdateSource("")
	}
	return d.Source
}

func (d *DocumentUpdateResponseBody) GetID() float64 {
	if d == nil {
		return 0.0
	}
	return d.ID
}

func (d *DocumentUpdateResponseBody) GetExternalID() *string {
	if d == nil {
		return nil
	}
	return d.ExternalID
}

func (d *DocumentUpdateResponseBody) GetUserID() float64 {
	if d == nil {
		return 0.0
	}
	return d.UserID
}

func (d *DocumentUpdateResponseBody) GetAuthOptions() *DocumentUpdateAuthOptions {
	if d == nil {
		return nil
	}
	return d.AuthOptions
}

func (d *DocumentUpdateResponseBody) GetFormValues() map[string]DocumentUpdateFormValues {
	if d == nil {
		return nil
	}
	return d.FormValues
}

func (d *DocumentUpdateResponseBody) GetTitle() string {
	if d == nil {
		return ""
	}
	return d.Title
}

func (d *DocumentUpdateResponseBody) GetCreatedAt() string {
	if d == nil {
		return ""
	}
	return d.CreatedAt
}

func (d *DocumentUpdateResponseBody) GetUpdatedAt() string {
	if d == nil {
		return ""
	}
	return d.UpdatedAt
}

func (d *DocumentUpdateResponseBody) GetCompletedAt() *string {
	if d == nil {
		return nil
	}
	return d.CompletedAt
}

func (d *DocumentUpdateResponseBody) GetDeletedAt() *string {
	if d == nil {
		return nil
	}
	return d.DeletedAt
}

func (d *DocumentUpdateResponseBody) GetTeamID() float64 {
	if d == nil {
		return 0.0
	}
	return d.TeamID
}

func (d *DocumentUpdateResponseBody) GetFolderID() *string {
	if d == nil {
		return nil
	}
	return d.FolderID
}

func (d *DocumentUpdateResponseBody) GetUseLegacyFieldInsertion() bool {
	if d == nil {
		return false
	}
	return d.UseLegacyFieldInsertion
}

func (d *DocumentUpdateResponseBody) GetEnvelopeID() string {
	if d == nil {
		return ""
	}
	return d.EnvelopeID
}

func (d *DocumentUpdateResponseBody) GetDocumentDataID() *string {
	if d == nil {
		return nil
	}
	return d.DocumentDataID
}

func (d *DocumentUpdateResponseBody) GetTemplateID() *float64 {
	if d == nil {
		return nil
	}
	return d.TemplateID
}

type DocumentUpdateResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Successful response
	Object *DocumentUpdateResponseBody
}

func (d *DocumentUpdateResponse) GetHTTPMeta() components.HTTPMetadata {
	if d == nil {
		return components.HTTPMetadata{}
	}
	return d.HTTPMeta
}

func (d *DocumentUpdateResponse) GetObject() *DocumentUpdateResponseBody {
	if d == nil {
		return nil
	}
	return d.Object
}
