// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/documenso/sdk-go/internal/utils"
	"github.com/documenso/sdk-go/models/components"
)

// VisibilityAccount - The visibility of the document.
type VisibilityAccount string

const (
	VisibilityAccountEveryone        VisibilityAccount = "EVERYONE"
	VisibilityAccountManagerAndAbove VisibilityAccount = "MANAGER_AND_ABOVE"
	VisibilityAccountAdmin           VisibilityAccount = "ADMIN"
)

func (e VisibilityAccount) ToPointer() *VisibilityAccount {
	return &e
}
func (e *VisibilityAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EVERYONE":
		fallthrough
	case "MANAGER_AND_ABOVE":
		fallthrough
	case "ADMIN":
		*e = VisibilityAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for VisibilityAccount: %v", v)
	}
}

// DocumentCreateDocumentTemporaryGlobalAccessAuthRequest - The type of authentication required for the recipient to access the document.
type DocumentCreateDocumentTemporaryGlobalAccessAuthRequest string

const (
	DocumentCreateDocumentTemporaryGlobalAccessAuthRequestAccount DocumentCreateDocumentTemporaryGlobalAccessAuthRequest = "ACCOUNT"
)

func (e DocumentCreateDocumentTemporaryGlobalAccessAuthRequest) ToPointer() *DocumentCreateDocumentTemporaryGlobalAccessAuthRequest {
	return &e
}
func (e *DocumentCreateDocumentTemporaryGlobalAccessAuthRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		*e = DocumentCreateDocumentTemporaryGlobalAccessAuthRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryGlobalAccessAuthRequest: %v", v)
	}
}

// GlobalActionAuthAccount - The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
type GlobalActionAuthAccount string

const (
	GlobalActionAuthAccountAccount       GlobalActionAuthAccount = "ACCOUNT"
	GlobalActionAuthAccountPasskey       GlobalActionAuthAccount = "PASSKEY"
	GlobalActionAuthAccountTwoFactorAuth GlobalActionAuthAccount = "TWO_FACTOR_AUTH"
)

func (e GlobalActionAuthAccount) ToPointer() *GlobalActionAuthAccount {
	return &e
}
func (e *GlobalActionAuthAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		*e = GlobalActionAuthAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GlobalActionAuthAccount: %v", v)
	}
}

type FormValuesRequestType string

const (
	FormValuesRequestTypeStr     FormValuesRequestType = "str"
	FormValuesRequestTypeBoolean FormValuesRequestType = "boolean"
	FormValuesRequestTypeNumber  FormValuesRequestType = "number"
)

type FormValuesRequest struct {
	Str     *string  `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`

	Type FormValuesRequestType
}

func CreateFormValuesRequestStr(str string) FormValuesRequest {
	typ := FormValuesRequestTypeStr

	return FormValuesRequest{
		Str:  &str,
		Type: typ,
	}
}

func CreateFormValuesRequestBoolean(boolean bool) FormValuesRequest {
	typ := FormValuesRequestTypeBoolean

	return FormValuesRequest{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateFormValuesRequestNumber(number float64) FormValuesRequest {
	typ := FormValuesRequestTypeNumber

	return FormValuesRequest{
		Number: &number,
		Type:   typ,
	}
}

func (u *FormValuesRequest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = FormValuesRequestTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = FormValuesRequestTypeBoolean
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = FormValuesRequestTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FormValuesRequest", string(data))
}

func (u FormValuesRequest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type FormValuesRequest: all fields are null")
}

type RoleAccount string

const (
	RoleAccountCc        RoleAccount = "CC"
	RoleAccountSigner    RoleAccount = "SIGNER"
	RoleAccountViewer    RoleAccount = "VIEWER"
	RoleAccountApprover  RoleAccount = "APPROVER"
	RoleAccountAssistant RoleAccount = "ASSISTANT"
)

func (e RoleAccount) ToPointer() *RoleAccount {
	return &e
}
func (e *RoleAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CC":
		fallthrough
	case "SIGNER":
		fallthrough
	case "VIEWER":
		fallthrough
	case "APPROVER":
		fallthrough
	case "ASSISTANT":
		*e = RoleAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RoleAccount: %v", v)
	}
}

// DocumentCreateDocumentTemporaryAccessAuthRequest - The type of authentication required for the recipient to access the document.
type DocumentCreateDocumentTemporaryAccessAuthRequest string

const (
	DocumentCreateDocumentTemporaryAccessAuthRequestAccount DocumentCreateDocumentTemporaryAccessAuthRequest = "ACCOUNT"
)

func (e DocumentCreateDocumentTemporaryAccessAuthRequest) ToPointer() *DocumentCreateDocumentTemporaryAccessAuthRequest {
	return &e
}
func (e *DocumentCreateDocumentTemporaryAccessAuthRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		*e = DocumentCreateDocumentTemporaryAccessAuthRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryAccessAuthRequest: %v", v)
	}
}

// ActionAuthAccount - The type of authentication required for the recipient to sign the document.
type ActionAuthAccount string

const (
	ActionAuthAccountAccount       ActionAuthAccount = "ACCOUNT"
	ActionAuthAccountPasskey       ActionAuthAccount = "PASSKEY"
	ActionAuthAccountTwoFactorAuth ActionAuthAccount = "TWO_FACTOR_AUTH"
	ActionAuthAccountExplicitNone  ActionAuthAccount = "EXPLICIT_NONE"
)

func (e ActionAuthAccount) ToPointer() *ActionAuthAccount {
	return &e
}
func (e *ActionAuthAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		fallthrough
	case "EXPLICIT_NONE":
		*e = ActionAuthAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ActionAuthAccount: %v", v)
	}
}

type TypeAccountDropdown1 string

const (
	TypeAccountDropdown1Dropdown TypeAccountDropdown1 = "DROPDOWN"
)

func (e TypeAccountDropdown1) ToPointer() *TypeAccountDropdown1 {
	return &e
}
func (e *TypeAccountDropdown1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DROPDOWN":
		*e = TypeAccountDropdown1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountDropdown1: %v", v)
	}
}

type TypeAccountDropdown2 string

const (
	TypeAccountDropdown2Dropdown TypeAccountDropdown2 = "dropdown"
)

func (e TypeAccountDropdown2) ToPointer() *TypeAccountDropdown2 {
	return &e
}
func (e *TypeAccountDropdown2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "dropdown":
		*e = TypeAccountDropdown2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountDropdown2: %v", v)
	}
}

type ValueAccountDropdown struct {
	Value string `json:"value"`
}

func (o *ValueAccountDropdown) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaAccountDropdown struct {
	Label        *string                `json:"label,omitempty"`
	Placeholder  *string                `json:"placeholder,omitempty"`
	Required     *bool                  `json:"required,omitempty"`
	ReadOnly     *bool                  `json:"readOnly,omitempty"`
	Type         TypeAccountDropdown2   `json:"type"`
	Values       []ValueAccountDropdown `json:"values,omitempty"`
	DefaultValue *string                `json:"defaultValue,omitempty"`
}

func (o *FieldMetaAccountDropdown) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountDropdown) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountDropdown) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountDropdown) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountDropdown) GetType() TypeAccountDropdown2 {
	if o == nil {
		return TypeAccountDropdown2("")
	}
	return o.Type
}

func (o *FieldMetaAccountDropdown) GetValues() []ValueAccountDropdown {
	if o == nil {
		return nil
	}
	return o.Values
}

func (o *FieldMetaAccountDropdown) GetDefaultValue() *string {
	if o == nil {
		return nil
	}
	return o.DefaultValue
}

type FieldAccountDropdown struct {
	Type      TypeAccountDropdown1      `json:"type"`
	FieldMeta *FieldMetaAccountDropdown `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountDropdown) GetType() TypeAccountDropdown1 {
	if o == nil {
		return TypeAccountDropdown1("")
	}
	return o.Type
}

func (o *FieldAccountDropdown) GetFieldMeta() *FieldMetaAccountDropdown {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountDropdown) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountDropdown) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountDropdown) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountDropdown) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountDropdown) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountCheckbox1 string

const (
	TypeAccountCheckbox1Checkbox TypeAccountCheckbox1 = "CHECKBOX"
)

func (e TypeAccountCheckbox1) ToPointer() *TypeAccountCheckbox1 {
	return &e
}
func (e *TypeAccountCheckbox1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CHECKBOX":
		*e = TypeAccountCheckbox1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountCheckbox1: %v", v)
	}
}

type TypeAccountCheckbox2 string

const (
	TypeAccountCheckbox2Checkbox TypeAccountCheckbox2 = "checkbox"
)

func (e TypeAccountCheckbox2) ToPointer() *TypeAccountCheckbox2 {
	return &e
}
func (e *TypeAccountCheckbox2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "checkbox":
		*e = TypeAccountCheckbox2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountCheckbox2: %v", v)
	}
}

type ValueAccountCheckbox struct {
	ID      float64 `json:"id"`
	Checked bool    `json:"checked"`
	Value   string  `json:"value"`
}

func (o *ValueAccountCheckbox) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *ValueAccountCheckbox) GetChecked() bool {
	if o == nil {
		return false
	}
	return o.Checked
}

func (o *ValueAccountCheckbox) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaAccountCheckbox struct {
	Label            *string                `json:"label,omitempty"`
	Placeholder      *string                `json:"placeholder,omitempty"`
	Required         *bool                  `json:"required,omitempty"`
	ReadOnly         *bool                  `json:"readOnly,omitempty"`
	Type             TypeAccountCheckbox2   `json:"type"`
	Values           []ValueAccountCheckbox `json:"values,omitempty"`
	ValidationRule   *string                `json:"validationRule,omitempty"`
	ValidationLength *float64               `json:"validationLength,omitempty"`
}

func (o *FieldMetaAccountCheckbox) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountCheckbox) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountCheckbox) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountCheckbox) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountCheckbox) GetType() TypeAccountCheckbox2 {
	if o == nil {
		return TypeAccountCheckbox2("")
	}
	return o.Type
}

func (o *FieldMetaAccountCheckbox) GetValues() []ValueAccountCheckbox {
	if o == nil {
		return nil
	}
	return o.Values
}

func (o *FieldMetaAccountCheckbox) GetValidationRule() *string {
	if o == nil {
		return nil
	}
	return o.ValidationRule
}

func (o *FieldMetaAccountCheckbox) GetValidationLength() *float64 {
	if o == nil {
		return nil
	}
	return o.ValidationLength
}

type FieldAccountCheckbox struct {
	Type      TypeAccountCheckbox1      `json:"type"`
	FieldMeta *FieldMetaAccountCheckbox `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountCheckbox) GetType() TypeAccountCheckbox1 {
	if o == nil {
		return TypeAccountCheckbox1("")
	}
	return o.Type
}

func (o *FieldAccountCheckbox) GetFieldMeta() *FieldMetaAccountCheckbox {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountCheckbox) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountCheckbox) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountCheckbox) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountCheckbox) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountCheckbox) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountRadio1 string

const (
	TypeAccountRadio1Radio TypeAccountRadio1 = "RADIO"
)

func (e TypeAccountRadio1) ToPointer() *TypeAccountRadio1 {
	return &e
}
func (e *TypeAccountRadio1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RADIO":
		*e = TypeAccountRadio1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountRadio1: %v", v)
	}
}

type TypeAccountRadio2 string

const (
	TypeAccountRadio2Radio TypeAccountRadio2 = "radio"
)

func (e TypeAccountRadio2) ToPointer() *TypeAccountRadio2 {
	return &e
}
func (e *TypeAccountRadio2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "radio":
		*e = TypeAccountRadio2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountRadio2: %v", v)
	}
}

type ValueAccountRadio struct {
	ID      float64 `json:"id"`
	Checked bool    `json:"checked"`
	Value   string  `json:"value"`
}

func (o *ValueAccountRadio) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *ValueAccountRadio) GetChecked() bool {
	if o == nil {
		return false
	}
	return o.Checked
}

func (o *ValueAccountRadio) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaAccountRadio struct {
	Label       *string             `json:"label,omitempty"`
	Placeholder *string             `json:"placeholder,omitempty"`
	Required    *bool               `json:"required,omitempty"`
	ReadOnly    *bool               `json:"readOnly,omitempty"`
	Type        TypeAccountRadio2   `json:"type"`
	Values      []ValueAccountRadio `json:"values,omitempty"`
}

func (o *FieldMetaAccountRadio) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountRadio) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountRadio) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountRadio) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountRadio) GetType() TypeAccountRadio2 {
	if o == nil {
		return TypeAccountRadio2("")
	}
	return o.Type
}

func (o *FieldMetaAccountRadio) GetValues() []ValueAccountRadio {
	if o == nil {
		return nil
	}
	return o.Values
}

type FieldAccountRadio struct {
	Type      TypeAccountRadio1      `json:"type"`
	FieldMeta *FieldMetaAccountRadio `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountRadio) GetType() TypeAccountRadio1 {
	if o == nil {
		return TypeAccountRadio1("")
	}
	return o.Type
}

func (o *FieldAccountRadio) GetFieldMeta() *FieldMetaAccountRadio {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountRadio) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountRadio) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountRadio) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountRadio) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountRadio) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountNumber1 string

const (
	TypeAccountNumber1Number TypeAccountNumber1 = "NUMBER"
)

func (e TypeAccountNumber1) ToPointer() *TypeAccountNumber1 {
	return &e
}
func (e *TypeAccountNumber1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NUMBER":
		*e = TypeAccountNumber1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountNumber1: %v", v)
	}
}

type TypeAccountNumber2 string

const (
	TypeAccountNumber2Number TypeAccountNumber2 = "number"
)

func (e TypeAccountNumber2) ToPointer() *TypeAccountNumber2 {
	return &e
}
func (e *TypeAccountNumber2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "number":
		*e = TypeAccountNumber2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountNumber2: %v", v)
	}
}

type TextAlignAccountNumber string

const (
	TextAlignAccountNumberLeft   TextAlignAccountNumber = "left"
	TextAlignAccountNumberCenter TextAlignAccountNumber = "center"
	TextAlignAccountNumberRight  TextAlignAccountNumber = "right"
)

func (e TextAlignAccountNumber) ToPointer() *TextAlignAccountNumber {
	return &e
}
func (e *TextAlignAccountNumber) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountNumber(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountNumber: %v", v)
	}
}

type FieldMetaAccountNumber struct {
	Label        *string                 `json:"label,omitempty"`
	Placeholder  *string                 `json:"placeholder,omitempty"`
	Required     *bool                   `json:"required,omitempty"`
	ReadOnly     *bool                   `json:"readOnly,omitempty"`
	Type         TypeAccountNumber2      `json:"type"`
	NumberFormat *string                 `json:"numberFormat,omitempty"`
	Value        *string                 `json:"value,omitempty"`
	MinValue     *float64                `json:"minValue,omitempty"`
	MaxValue     *float64                `json:"maxValue,omitempty"`
	FontSize     *float64                `json:"fontSize,omitempty"`
	TextAlign    *TextAlignAccountNumber `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountNumber) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountNumber) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountNumber) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountNumber) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountNumber) GetType() TypeAccountNumber2 {
	if o == nil {
		return TypeAccountNumber2("")
	}
	return o.Type
}

func (o *FieldMetaAccountNumber) GetNumberFormat() *string {
	if o == nil {
		return nil
	}
	return o.NumberFormat
}

func (o *FieldMetaAccountNumber) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *FieldMetaAccountNumber) GetMinValue() *float64 {
	if o == nil {
		return nil
	}
	return o.MinValue
}

func (o *FieldMetaAccountNumber) GetMaxValue() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxValue
}

func (o *FieldMetaAccountNumber) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountNumber) GetTextAlign() *TextAlignAccountNumber {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountNumber struct {
	Type      TypeAccountNumber1      `json:"type"`
	FieldMeta *FieldMetaAccountNumber `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountNumber) GetType() TypeAccountNumber1 {
	if o == nil {
		return TypeAccountNumber1("")
	}
	return o.Type
}

func (o *FieldAccountNumber) GetFieldMeta() *FieldMetaAccountNumber {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountNumber) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountNumber) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountNumber) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountNumber) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountNumber) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountText1 string

const (
	TypeAccountText1Text TypeAccountText1 = "TEXT"
)

func (e TypeAccountText1) ToPointer() *TypeAccountText1 {
	return &e
}
func (e *TypeAccountText1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TEXT":
		*e = TypeAccountText1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountText1: %v", v)
	}
}

type TypeAccountText2 string

const (
	TypeAccountText2Text TypeAccountText2 = "text"
)

func (e TypeAccountText2) ToPointer() *TypeAccountText2 {
	return &e
}
func (e *TypeAccountText2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		*e = TypeAccountText2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountText2: %v", v)
	}
}

type TextAlignAccountText string

const (
	TextAlignAccountTextLeft   TextAlignAccountText = "left"
	TextAlignAccountTextCenter TextAlignAccountText = "center"
	TextAlignAccountTextRight  TextAlignAccountText = "right"
)

func (e TextAlignAccountText) ToPointer() *TextAlignAccountText {
	return &e
}
func (e *TextAlignAccountText) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountText(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountText: %v", v)
	}
}

type FieldMetaAccountText struct {
	Label          *string               `json:"label,omitempty"`
	Placeholder    *string               `json:"placeholder,omitempty"`
	Required       *bool                 `json:"required,omitempty"`
	ReadOnly       *bool                 `json:"readOnly,omitempty"`
	Type           TypeAccountText2      `json:"type"`
	Text           *string               `json:"text,omitempty"`
	CharacterLimit *float64              `json:"characterLimit,omitempty"`
	FontSize       *float64              `json:"fontSize,omitempty"`
	TextAlign      *TextAlignAccountText `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountText) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountText) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountText) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountText) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountText) GetType() TypeAccountText2 {
	if o == nil {
		return TypeAccountText2("")
	}
	return o.Type
}

func (o *FieldMetaAccountText) GetText() *string {
	if o == nil {
		return nil
	}
	return o.Text
}

func (o *FieldMetaAccountText) GetCharacterLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.CharacterLimit
}

func (o *FieldMetaAccountText) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountText) GetTextAlign() *TextAlignAccountText {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountText struct {
	Type      TypeAccountText1      `json:"type"`
	FieldMeta *FieldMetaAccountText `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountText) GetType() TypeAccountText1 {
	if o == nil {
		return TypeAccountText1("")
	}
	return o.Type
}

func (o *FieldAccountText) GetFieldMeta() *FieldMetaAccountText {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountText) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountText) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountText) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountText) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountText) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountDate1 string

const (
	TypeAccountDate1Date TypeAccountDate1 = "DATE"
)

func (e TypeAccountDate1) ToPointer() *TypeAccountDate1 {
	return &e
}
func (e *TypeAccountDate1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DATE":
		*e = TypeAccountDate1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountDate1: %v", v)
	}
}

type TypeAccountDate2 string

const (
	TypeAccountDate2Date TypeAccountDate2 = "date"
)

func (e TypeAccountDate2) ToPointer() *TypeAccountDate2 {
	return &e
}
func (e *TypeAccountDate2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "date":
		*e = TypeAccountDate2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountDate2: %v", v)
	}
}

type TextAlignAccountDate string

const (
	TextAlignAccountDateLeft   TextAlignAccountDate = "left"
	TextAlignAccountDateCenter TextAlignAccountDate = "center"
	TextAlignAccountDateRight  TextAlignAccountDate = "right"
)

func (e TextAlignAccountDate) ToPointer() *TextAlignAccountDate {
	return &e
}
func (e *TextAlignAccountDate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountDate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountDate: %v", v)
	}
}

type FieldMetaAccountDate struct {
	Label       *string               `json:"label,omitempty"`
	Placeholder *string               `json:"placeholder,omitempty"`
	Required    *bool                 `json:"required,omitempty"`
	ReadOnly    *bool                 `json:"readOnly,omitempty"`
	Type        TypeAccountDate2      `json:"type"`
	FontSize    *float64              `json:"fontSize,omitempty"`
	TextAlign   *TextAlignAccountDate `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountDate) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountDate) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountDate) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountDate) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountDate) GetType() TypeAccountDate2 {
	if o == nil {
		return TypeAccountDate2("")
	}
	return o.Type
}

func (o *FieldMetaAccountDate) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountDate) GetTextAlign() *TextAlignAccountDate {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountDate struct {
	Type      TypeAccountDate1      `json:"type"`
	FieldMeta *FieldMetaAccountDate `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountDate) GetType() TypeAccountDate1 {
	if o == nil {
		return TypeAccountDate1("")
	}
	return o.Type
}

func (o *FieldAccountDate) GetFieldMeta() *FieldMetaAccountDate {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountDate) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountDate) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountDate) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountDate) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountDate) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountEmail1 string

const (
	TypeAccountEmail1Email TypeAccountEmail1 = "EMAIL"
)

func (e TypeAccountEmail1) ToPointer() *TypeAccountEmail1 {
	return &e
}
func (e *TypeAccountEmail1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EMAIL":
		*e = TypeAccountEmail1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountEmail1: %v", v)
	}
}

type TypeAccountEmail2 string

const (
	TypeAccountEmail2Email TypeAccountEmail2 = "email"
)

func (e TypeAccountEmail2) ToPointer() *TypeAccountEmail2 {
	return &e
}
func (e *TypeAccountEmail2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "email":
		*e = TypeAccountEmail2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountEmail2: %v", v)
	}
}

type TextAlignAccountEmail string

const (
	TextAlignAccountEmailLeft   TextAlignAccountEmail = "left"
	TextAlignAccountEmailCenter TextAlignAccountEmail = "center"
	TextAlignAccountEmailRight  TextAlignAccountEmail = "right"
)

func (e TextAlignAccountEmail) ToPointer() *TextAlignAccountEmail {
	return &e
}
func (e *TextAlignAccountEmail) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountEmail(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountEmail: %v", v)
	}
}

type FieldMetaAccountEmail struct {
	Label       *string                `json:"label,omitempty"`
	Placeholder *string                `json:"placeholder,omitempty"`
	Required    *bool                  `json:"required,omitempty"`
	ReadOnly    *bool                  `json:"readOnly,omitempty"`
	Type        TypeAccountEmail2      `json:"type"`
	FontSize    *float64               `json:"fontSize,omitempty"`
	TextAlign   *TextAlignAccountEmail `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountEmail) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountEmail) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountEmail) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountEmail) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountEmail) GetType() TypeAccountEmail2 {
	if o == nil {
		return TypeAccountEmail2("")
	}
	return o.Type
}

func (o *FieldMetaAccountEmail) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountEmail) GetTextAlign() *TextAlignAccountEmail {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountEmail struct {
	Type      TypeAccountEmail1      `json:"type"`
	FieldMeta *FieldMetaAccountEmail `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountEmail) GetType() TypeAccountEmail1 {
	if o == nil {
		return TypeAccountEmail1("")
	}
	return o.Type
}

func (o *FieldAccountEmail) GetFieldMeta() *FieldMetaAccountEmail {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountEmail) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountEmail) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountEmail) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountEmail) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountEmail) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountName1 string

const (
	TypeAccountName1Name TypeAccountName1 = "NAME"
)

func (e TypeAccountName1) ToPointer() *TypeAccountName1 {
	return &e
}
func (e *TypeAccountName1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NAME":
		*e = TypeAccountName1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountName1: %v", v)
	}
}

type TypeAccountName2 string

const (
	TypeAccountName2Name TypeAccountName2 = "name"
)

func (e TypeAccountName2) ToPointer() *TypeAccountName2 {
	return &e
}
func (e *TypeAccountName2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "name":
		*e = TypeAccountName2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountName2: %v", v)
	}
}

type TextAlignAccountName string

const (
	TextAlignAccountNameLeft   TextAlignAccountName = "left"
	TextAlignAccountNameCenter TextAlignAccountName = "center"
	TextAlignAccountNameRight  TextAlignAccountName = "right"
)

func (e TextAlignAccountName) ToPointer() *TextAlignAccountName {
	return &e
}
func (e *TextAlignAccountName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountName: %v", v)
	}
}

type FieldMetaAccountName struct {
	Label       *string               `json:"label,omitempty"`
	Placeholder *string               `json:"placeholder,omitempty"`
	Required    *bool                 `json:"required,omitempty"`
	ReadOnly    *bool                 `json:"readOnly,omitempty"`
	Type        TypeAccountName2      `json:"type"`
	FontSize    *float64              `json:"fontSize,omitempty"`
	TextAlign   *TextAlignAccountName `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountName) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountName) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountName) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountName) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountName) GetType() TypeAccountName2 {
	if o == nil {
		return TypeAccountName2("")
	}
	return o.Type
}

func (o *FieldMetaAccountName) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountName) GetTextAlign() *TextAlignAccountName {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountName struct {
	Type      TypeAccountName1      `json:"type"`
	FieldMeta *FieldMetaAccountName `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountName) GetType() TypeAccountName1 {
	if o == nil {
		return TypeAccountName1("")
	}
	return o.Type
}

func (o *FieldAccountName) GetFieldMeta() *FieldMetaAccountName {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountName) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountName) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountName) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountName) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountName) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountInitials1 string

const (
	TypeAccountInitials1Initials TypeAccountInitials1 = "INITIALS"
)

func (e TypeAccountInitials1) ToPointer() *TypeAccountInitials1 {
	return &e
}
func (e *TypeAccountInitials1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INITIALS":
		*e = TypeAccountInitials1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountInitials1: %v", v)
	}
}

type TypeAccountInitials2 string

const (
	TypeAccountInitials2Initials TypeAccountInitials2 = "initials"
)

func (e TypeAccountInitials2) ToPointer() *TypeAccountInitials2 {
	return &e
}
func (e *TypeAccountInitials2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "initials":
		*e = TypeAccountInitials2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountInitials2: %v", v)
	}
}

type TextAlignAccountInitials string

const (
	TextAlignAccountInitialsLeft   TextAlignAccountInitials = "left"
	TextAlignAccountInitialsCenter TextAlignAccountInitials = "center"
	TextAlignAccountInitialsRight  TextAlignAccountInitials = "right"
)

func (e TextAlignAccountInitials) ToPointer() *TextAlignAccountInitials {
	return &e
}
func (e *TextAlignAccountInitials) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = TextAlignAccountInitials(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TextAlignAccountInitials: %v", v)
	}
}

type FieldMetaAccountInitials struct {
	Label       *string                   `json:"label,omitempty"`
	Placeholder *string                   `json:"placeholder,omitempty"`
	Required    *bool                     `json:"required,omitempty"`
	ReadOnly    *bool                     `json:"readOnly,omitempty"`
	Type        TypeAccountInitials2      `json:"type"`
	FontSize    *float64                  `json:"fontSize,omitempty"`
	TextAlign   *TextAlignAccountInitials `json:"textAlign,omitempty"`
}

func (o *FieldMetaAccountInitials) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaAccountInitials) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaAccountInitials) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaAccountInitials) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaAccountInitials) GetType() TypeAccountInitials2 {
	if o == nil {
		return TypeAccountInitials2("")
	}
	return o.Type
}

func (o *FieldMetaAccountInitials) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaAccountInitials) GetTextAlign() *TextAlignAccountInitials {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type FieldAccountInitials struct {
	Type      TypeAccountInitials1      `json:"type"`
	FieldMeta *FieldMetaAccountInitials `json:"fieldMeta,omitempty"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountInitials) GetType() TypeAccountInitials1 {
	if o == nil {
		return TypeAccountInitials1("")
	}
	return o.Type
}

func (o *FieldAccountInitials) GetFieldMeta() *FieldMetaAccountInitials {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

func (o *FieldAccountInitials) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountInitials) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountInitials) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountInitials) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountInitials) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountFreeSignature string

const (
	TypeAccountFreeSignatureFreeSignature TypeAccountFreeSignature = "FREE_SIGNATURE"
)

func (e TypeAccountFreeSignature) ToPointer() *TypeAccountFreeSignature {
	return &e
}
func (e *TypeAccountFreeSignature) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FREE_SIGNATURE":
		*e = TypeAccountFreeSignature(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountFreeSignature: %v", v)
	}
}

type FieldAccountFreeSignature struct {
	Type TypeAccountFreeSignature `json:"type"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountFreeSignature) GetType() TypeAccountFreeSignature {
	if o == nil {
		return TypeAccountFreeSignature("")
	}
	return o.Type
}

func (o *FieldAccountFreeSignature) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountFreeSignature) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountFreeSignature) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountFreeSignature) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountFreeSignature) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type TypeAccountSignature string

const (
	TypeAccountSignatureSignature TypeAccountSignature = "SIGNATURE"
)

func (e TypeAccountSignature) ToPointer() *TypeAccountSignature {
	return &e
}
func (e *TypeAccountSignature) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SIGNATURE":
		*e = TypeAccountSignature(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAccountSignature: %v", v)
	}
}

type FieldAccountSignature struct {
	Type TypeAccountSignature `json:"type"`
	// The page number the field will be on.
	PageNumber float64 `json:"pageNumber"`
	// The X coordinate of where the field will be placed.
	PageX float64 `json:"pageX"`
	// The Y coordinate of where the field will be placed.
	PageY float64 `json:"pageY"`
	// The width of the field.
	Width float64 `json:"width"`
	// The height of the field.
	Height float64 `json:"height"`
}

func (o *FieldAccountSignature) GetType() TypeAccountSignature {
	if o == nil {
		return TypeAccountSignature("")
	}
	return o.Type
}

func (o *FieldAccountSignature) GetPageNumber() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageNumber
}

func (o *FieldAccountSignature) GetPageX() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageX
}

func (o *FieldAccountSignature) GetPageY() float64 {
	if o == nil {
		return 0.0
	}
	return o.PageY
}

func (o *FieldAccountSignature) GetWidth() float64 {
	if o == nil {
		return 0.0
	}
	return o.Width
}

func (o *FieldAccountSignature) GetHeight() float64 {
	if o == nil {
		return 0.0
	}
	return o.Height
}

type FieldAccountUnionType string

const (
	FieldAccountUnionTypeFieldAccountSignature     FieldAccountUnionType = "field_Account_Signature"
	FieldAccountUnionTypeFieldAccountFreeSignature FieldAccountUnionType = "field_Account_FreeSignature"
	FieldAccountUnionTypeFieldAccountInitials      FieldAccountUnionType = "field_Account_Initials"
	FieldAccountUnionTypeFieldAccountName          FieldAccountUnionType = "field_Account_Name"
	FieldAccountUnionTypeFieldAccountEmail         FieldAccountUnionType = "field_Account_Email"
	FieldAccountUnionTypeFieldAccountDate          FieldAccountUnionType = "field_Account_Date"
	FieldAccountUnionTypeFieldAccountText          FieldAccountUnionType = "field_Account_Text"
	FieldAccountUnionTypeFieldAccountNumber        FieldAccountUnionType = "field_Account_Number"
	FieldAccountUnionTypeFieldAccountRadio         FieldAccountUnionType = "field_Account_Radio"
	FieldAccountUnionTypeFieldAccountCheckbox      FieldAccountUnionType = "field_Account_Checkbox"
	FieldAccountUnionTypeFieldAccountDropdown      FieldAccountUnionType = "field_Account_Dropdown"
)

type FieldAccountUnion struct {
	FieldAccountSignature     *FieldAccountSignature     `queryParam:"inline"`
	FieldAccountFreeSignature *FieldAccountFreeSignature `queryParam:"inline"`
	FieldAccountInitials      *FieldAccountInitials      `queryParam:"inline"`
	FieldAccountName          *FieldAccountName          `queryParam:"inline"`
	FieldAccountEmail         *FieldAccountEmail         `queryParam:"inline"`
	FieldAccountDate          *FieldAccountDate          `queryParam:"inline"`
	FieldAccountText          *FieldAccountText          `queryParam:"inline"`
	FieldAccountNumber        *FieldAccountNumber        `queryParam:"inline"`
	FieldAccountRadio         *FieldAccountRadio         `queryParam:"inline"`
	FieldAccountCheckbox      *FieldAccountCheckbox      `queryParam:"inline"`
	FieldAccountDropdown      *FieldAccountDropdown      `queryParam:"inline"`

	Type FieldAccountUnionType
}

func CreateFieldAccountUnionFieldAccountSignature(fieldAccountSignature FieldAccountSignature) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountSignature

	return FieldAccountUnion{
		FieldAccountSignature: &fieldAccountSignature,
		Type:                  typ,
	}
}

func CreateFieldAccountUnionFieldAccountFreeSignature(fieldAccountFreeSignature FieldAccountFreeSignature) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountFreeSignature

	return FieldAccountUnion{
		FieldAccountFreeSignature: &fieldAccountFreeSignature,
		Type:                      typ,
	}
}

func CreateFieldAccountUnionFieldAccountInitials(fieldAccountInitials FieldAccountInitials) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountInitials

	return FieldAccountUnion{
		FieldAccountInitials: &fieldAccountInitials,
		Type:                 typ,
	}
}

func CreateFieldAccountUnionFieldAccountName(fieldAccountName FieldAccountName) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountName

	return FieldAccountUnion{
		FieldAccountName: &fieldAccountName,
		Type:             typ,
	}
}

func CreateFieldAccountUnionFieldAccountEmail(fieldAccountEmail FieldAccountEmail) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountEmail

	return FieldAccountUnion{
		FieldAccountEmail: &fieldAccountEmail,
		Type:              typ,
	}
}

func CreateFieldAccountUnionFieldAccountDate(fieldAccountDate FieldAccountDate) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountDate

	return FieldAccountUnion{
		FieldAccountDate: &fieldAccountDate,
		Type:             typ,
	}
}

func CreateFieldAccountUnionFieldAccountText(fieldAccountText FieldAccountText) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountText

	return FieldAccountUnion{
		FieldAccountText: &fieldAccountText,
		Type:             typ,
	}
}

func CreateFieldAccountUnionFieldAccountNumber(fieldAccountNumber FieldAccountNumber) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountNumber

	return FieldAccountUnion{
		FieldAccountNumber: &fieldAccountNumber,
		Type:               typ,
	}
}

func CreateFieldAccountUnionFieldAccountRadio(fieldAccountRadio FieldAccountRadio) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountRadio

	return FieldAccountUnion{
		FieldAccountRadio: &fieldAccountRadio,
		Type:              typ,
	}
}

func CreateFieldAccountUnionFieldAccountCheckbox(fieldAccountCheckbox FieldAccountCheckbox) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountCheckbox

	return FieldAccountUnion{
		FieldAccountCheckbox: &fieldAccountCheckbox,
		Type:                 typ,
	}
}

func CreateFieldAccountUnionFieldAccountDropdown(fieldAccountDropdown FieldAccountDropdown) FieldAccountUnion {
	typ := FieldAccountUnionTypeFieldAccountDropdown

	return FieldAccountUnion{
		FieldAccountDropdown: &fieldAccountDropdown,
		Type:                 typ,
	}
}

func (u *FieldAccountUnion) UnmarshalJSON(data []byte) error {

	var fieldAccountSignature FieldAccountSignature = FieldAccountSignature{}
	if err := utils.UnmarshalJSON(data, &fieldAccountSignature, "", true, true); err == nil {
		u.FieldAccountSignature = &fieldAccountSignature
		u.Type = FieldAccountUnionTypeFieldAccountSignature
		return nil
	}

	var fieldAccountFreeSignature FieldAccountFreeSignature = FieldAccountFreeSignature{}
	if err := utils.UnmarshalJSON(data, &fieldAccountFreeSignature, "", true, true); err == nil {
		u.FieldAccountFreeSignature = &fieldAccountFreeSignature
		u.Type = FieldAccountUnionTypeFieldAccountFreeSignature
		return nil
	}

	var fieldAccountInitials FieldAccountInitials = FieldAccountInitials{}
	if err := utils.UnmarshalJSON(data, &fieldAccountInitials, "", true, true); err == nil {
		u.FieldAccountInitials = &fieldAccountInitials
		u.Type = FieldAccountUnionTypeFieldAccountInitials
		return nil
	}

	var fieldAccountName FieldAccountName = FieldAccountName{}
	if err := utils.UnmarshalJSON(data, &fieldAccountName, "", true, true); err == nil {
		u.FieldAccountName = &fieldAccountName
		u.Type = FieldAccountUnionTypeFieldAccountName
		return nil
	}

	var fieldAccountEmail FieldAccountEmail = FieldAccountEmail{}
	if err := utils.UnmarshalJSON(data, &fieldAccountEmail, "", true, true); err == nil {
		u.FieldAccountEmail = &fieldAccountEmail
		u.Type = FieldAccountUnionTypeFieldAccountEmail
		return nil
	}

	var fieldAccountDate FieldAccountDate = FieldAccountDate{}
	if err := utils.UnmarshalJSON(data, &fieldAccountDate, "", true, true); err == nil {
		u.FieldAccountDate = &fieldAccountDate
		u.Type = FieldAccountUnionTypeFieldAccountDate
		return nil
	}

	var fieldAccountText FieldAccountText = FieldAccountText{}
	if err := utils.UnmarshalJSON(data, &fieldAccountText, "", true, true); err == nil {
		u.FieldAccountText = &fieldAccountText
		u.Type = FieldAccountUnionTypeFieldAccountText
		return nil
	}

	var fieldAccountNumber FieldAccountNumber = FieldAccountNumber{}
	if err := utils.UnmarshalJSON(data, &fieldAccountNumber, "", true, true); err == nil {
		u.FieldAccountNumber = &fieldAccountNumber
		u.Type = FieldAccountUnionTypeFieldAccountNumber
		return nil
	}

	var fieldAccountRadio FieldAccountRadio = FieldAccountRadio{}
	if err := utils.UnmarshalJSON(data, &fieldAccountRadio, "", true, true); err == nil {
		u.FieldAccountRadio = &fieldAccountRadio
		u.Type = FieldAccountUnionTypeFieldAccountRadio
		return nil
	}

	var fieldAccountCheckbox FieldAccountCheckbox = FieldAccountCheckbox{}
	if err := utils.UnmarshalJSON(data, &fieldAccountCheckbox, "", true, true); err == nil {
		u.FieldAccountCheckbox = &fieldAccountCheckbox
		u.Type = FieldAccountUnionTypeFieldAccountCheckbox
		return nil
	}

	var fieldAccountDropdown FieldAccountDropdown = FieldAccountDropdown{}
	if err := utils.UnmarshalJSON(data, &fieldAccountDropdown, "", true, true); err == nil {
		u.FieldAccountDropdown = &fieldAccountDropdown
		u.Type = FieldAccountUnionTypeFieldAccountDropdown
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FieldAccountUnion", string(data))
}

func (u FieldAccountUnion) MarshalJSON() ([]byte, error) {
	if u.FieldAccountSignature != nil {
		return utils.MarshalJSON(u.FieldAccountSignature, "", true)
	}

	if u.FieldAccountFreeSignature != nil {
		return utils.MarshalJSON(u.FieldAccountFreeSignature, "", true)
	}

	if u.FieldAccountInitials != nil {
		return utils.MarshalJSON(u.FieldAccountInitials, "", true)
	}

	if u.FieldAccountName != nil {
		return utils.MarshalJSON(u.FieldAccountName, "", true)
	}

	if u.FieldAccountEmail != nil {
		return utils.MarshalJSON(u.FieldAccountEmail, "", true)
	}

	if u.FieldAccountDate != nil {
		return utils.MarshalJSON(u.FieldAccountDate, "", true)
	}

	if u.FieldAccountText != nil {
		return utils.MarshalJSON(u.FieldAccountText, "", true)
	}

	if u.FieldAccountNumber != nil {
		return utils.MarshalJSON(u.FieldAccountNumber, "", true)
	}

	if u.FieldAccountRadio != nil {
		return utils.MarshalJSON(u.FieldAccountRadio, "", true)
	}

	if u.FieldAccountCheckbox != nil {
		return utils.MarshalJSON(u.FieldAccountCheckbox, "", true)
	}

	if u.FieldAccountDropdown != nil {
		return utils.MarshalJSON(u.FieldAccountDropdown, "", true)
	}

	return nil, errors.New("could not marshal union type FieldAccountUnion: all fields are null")
}

type RecipientAccount struct {
	Email        string      `json:"email"`
	Name         string      `json:"name"`
	Role         RoleAccount `json:"role"`
	SigningOrder *float64    `json:"signingOrder,omitempty"`
	// The type of authentication required for the recipient to access the document.
	AccessAuth *DocumentCreateDocumentTemporaryAccessAuthRequest `json:"accessAuth,omitempty"`
	// The type of authentication required for the recipient to sign the document.
	ActionAuth *ActionAuthAccount  `json:"actionAuth,omitempty"`
	Fields     []FieldAccountUnion `json:"fields,omitempty"`
}

func (o *RecipientAccount) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *RecipientAccount) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *RecipientAccount) GetRole() RoleAccount {
	if o == nil {
		return RoleAccount("")
	}
	return o.Role
}

func (o *RecipientAccount) GetSigningOrder() *float64 {
	if o == nil {
		return nil
	}
	return o.SigningOrder
}

func (o *RecipientAccount) GetAccessAuth() *DocumentCreateDocumentTemporaryAccessAuthRequest {
	if o == nil {
		return nil
	}
	return o.AccessAuth
}

func (o *RecipientAccount) GetActionAuth() *ActionAuthAccount {
	if o == nil {
		return nil
	}
	return o.ActionAuth
}

func (o *RecipientAccount) GetFields() []FieldAccountUnion {
	if o == nil {
		return nil
	}
	return o.Fields
}

// DocumentCreateDocumentTemporaryDateFormat - The date format to use for date fields and signing the document.
type DocumentCreateDocumentTemporaryDateFormat string

const (
	DocumentCreateDocumentTemporaryDateFormatYyyyMmDdHhMmA         DocumentCreateDocumentTemporaryDateFormat = "yyyy-MM-dd hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatYyyyMmDd              DocumentCreateDocumentTemporaryDateFormat = "yyyy-MM-dd"
	DocumentCreateDocumentTemporaryDateFormatDdMmYyyyHhMmA         DocumentCreateDocumentTemporaryDateFormat = "dd/MM/yyyy hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatMmDdYyyyHhMmA         DocumentCreateDocumentTemporaryDateFormat = "MM/dd/yyyy hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatYyyyMmDdHhMm          DocumentCreateDocumentTemporaryDateFormat = "yyyy-MM-dd HH:mm"
	DocumentCreateDocumentTemporaryDateFormatYyMmDdHhMmA           DocumentCreateDocumentTemporaryDateFormat = "yy-MM-dd hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatYyyyMmDdHhMmSs        DocumentCreateDocumentTemporaryDateFormat = "yyyy-MM-dd HH:mm:ss"
	DocumentCreateDocumentTemporaryDateFormatMmmmDdYyyyHhMmA       DocumentCreateDocumentTemporaryDateFormat = "MMMM dd, yyyy hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatEeeeMmmmDdYyyyHhMmA   DocumentCreateDocumentTemporaryDateFormat = "EEEE, MMMM dd, yyyy hh:mm a"
	DocumentCreateDocumentTemporaryDateFormatYyyyMmDdTHhMmSsSssxxx DocumentCreateDocumentTemporaryDateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSXXX"
)

func (e DocumentCreateDocumentTemporaryDateFormat) ToPointer() *DocumentCreateDocumentTemporaryDateFormat {
	return &e
}
func (e *DocumentCreateDocumentTemporaryDateFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "yyyy-MM-dd hh:mm a":
		fallthrough
	case "yyyy-MM-dd":
		fallthrough
	case "dd/MM/yyyy hh:mm a":
		fallthrough
	case "MM/dd/yyyy hh:mm a":
		fallthrough
	case "yyyy-MM-dd HH:mm":
		fallthrough
	case "yy-MM-dd hh:mm a":
		fallthrough
	case "yyyy-MM-dd HH:mm:ss":
		fallthrough
	case "MMMM dd, yyyy hh:mm a":
		fallthrough
	case "EEEE, MMMM dd, yyyy hh:mm a":
		fallthrough
	case "yyyy-MM-dd'T'HH:mm:ss.SSSXXX":
		*e = DocumentCreateDocumentTemporaryDateFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryDateFormat: %v", v)
	}
}

// DistributionMethodAccount - The distribution method to use when sending the document to the recipients.
type DistributionMethodAccount string

const (
	DistributionMethodAccountEmail DistributionMethodAccount = "EMAIL"
	DistributionMethodAccountNone  DistributionMethodAccount = "NONE"
)

func (e DistributionMethodAccount) ToPointer() *DistributionMethodAccount {
	return &e
}
func (e *DistributionMethodAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EMAIL":
		fallthrough
	case "NONE":
		*e = DistributionMethodAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DistributionMethodAccount: %v", v)
	}
}

type SigningOrderAccount string

const (
	SigningOrderAccountParallel   SigningOrderAccount = "PARALLEL"
	SigningOrderAccountSequential SigningOrderAccount = "SEQUENTIAL"
)

func (e SigningOrderAccount) ToPointer() *SigningOrderAccount {
	return &e
}
func (e *SigningOrderAccount) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PARALLEL":
		fallthrough
	case "SEQUENTIAL":
		*e = SigningOrderAccount(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SigningOrderAccount: %v", v)
	}
}

// DocumentCreateDocumentTemporaryLanguage - The language to use for email communications with recipients.
type DocumentCreateDocumentTemporaryLanguage string

const (
	DocumentCreateDocumentTemporaryLanguageDe DocumentCreateDocumentTemporaryLanguage = "de"
	DocumentCreateDocumentTemporaryLanguageEn DocumentCreateDocumentTemporaryLanguage = "en"
	DocumentCreateDocumentTemporaryLanguageFr DocumentCreateDocumentTemporaryLanguage = "fr"
	DocumentCreateDocumentTemporaryLanguageEs DocumentCreateDocumentTemporaryLanguage = "es"
	DocumentCreateDocumentTemporaryLanguageIt DocumentCreateDocumentTemporaryLanguage = "it"
	DocumentCreateDocumentTemporaryLanguagePl DocumentCreateDocumentTemporaryLanguage = "pl"
)

func (e DocumentCreateDocumentTemporaryLanguage) ToPointer() *DocumentCreateDocumentTemporaryLanguage {
	return &e
}
func (e *DocumentCreateDocumentTemporaryLanguage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "de":
		fallthrough
	case "en":
		fallthrough
	case "fr":
		fallthrough
	case "es":
		fallthrough
	case "it":
		fallthrough
	case "pl":
		*e = DocumentCreateDocumentTemporaryLanguage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryLanguage: %v", v)
	}
}

type EmailSettingsAccount struct {
	// Whether to send an email to all recipients that the document is ready for them to sign.
	RecipientSigningRequest *bool `default:"true" json:"recipientSigningRequest"`
	// Whether to send an email to the recipient who was removed from a pending document.
	RecipientRemoved *bool `default:"true" json:"recipientRemoved"`
	// Whether to send an email to the document owner when a recipient has signed the document.
	RecipientSigned *bool `default:"true" json:"recipientSigned"`
	// Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed.
	DocumentPending *bool `default:"true" json:"documentPending"`
	// Whether to send an email to all recipients when the document is complete.
	DocumentCompleted *bool `default:"true" json:"documentCompleted"`
	// Whether to send an email to all recipients if a pending document has been deleted.
	DocumentDeleted *bool `default:"true" json:"documentDeleted"`
	// Whether to send an email to the document owner when the document is complete.
	OwnerDocumentCompleted *bool `default:"true" json:"ownerDocumentCompleted"`
}

func (e EmailSettingsAccount) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *EmailSettingsAccount) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *EmailSettingsAccount) GetRecipientSigningRequest() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientSigningRequest
}

func (o *EmailSettingsAccount) GetRecipientRemoved() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientRemoved
}

func (o *EmailSettingsAccount) GetRecipientSigned() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientSigned
}

func (o *EmailSettingsAccount) GetDocumentPending() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentPending
}

func (o *EmailSettingsAccount) GetDocumentCompleted() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentCompleted
}

func (o *EmailSettingsAccount) GetDocumentDeleted() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentDeleted
}

func (o *EmailSettingsAccount) GetOwnerDocumentCompleted() *bool {
	if o == nil {
		return nil
	}
	return o.OwnerDocumentCompleted
}

type DocumentCreateDocumentTemporaryMeta struct {
	// The subject of the email that will be sent to the recipients.
	Subject *string `json:"subject,omitempty"`
	// The message of the email that will be sent to the recipients.
	Message *string `json:"message,omitempty"`
	// The timezone to use for date fields and signing the document. Example Etc/UTC, Australia/Melbourne
	Timezone *string `json:"timezone,omitempty"`
	// The date format to use for date fields and signing the document.
	DateFormat *DocumentCreateDocumentTemporaryDateFormat `json:"dateFormat,omitempty"`
	// The distribution method to use when sending the document to the recipients.
	DistributionMethod *DistributionMethodAccount `json:"distributionMethod,omitempty"`
	SigningOrder       *SigningOrderAccount       `json:"signingOrder,omitempty"`
	// The URL to which the recipient should be redirected after signing the document.
	RedirectURL *string `json:"redirectUrl,omitempty"`
	// The language to use for email communications with recipients.
	Language *DocumentCreateDocumentTemporaryLanguage `json:"language,omitempty"`
	// Whether to allow recipients to sign using a typed signature.
	TypedSignatureEnabled *bool `json:"typedSignatureEnabled,omitempty"`
	// Whether to allow recipients to sign using a draw signature.
	DrawSignatureEnabled *bool `json:"drawSignatureEnabled,omitempty"`
	// Whether to allow recipients to sign using an uploaded signature.
	UploadSignatureEnabled *bool                 `json:"uploadSignatureEnabled,omitempty"`
	EmailSettings          *EmailSettingsAccount `json:"emailSettings,omitempty"`
}

func (o *DocumentCreateDocumentTemporaryMeta) GetSubject() *string {
	if o == nil {
		return nil
	}
	return o.Subject
}

func (o *DocumentCreateDocumentTemporaryMeta) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *DocumentCreateDocumentTemporaryMeta) GetTimezone() *string {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *DocumentCreateDocumentTemporaryMeta) GetDateFormat() *DocumentCreateDocumentTemporaryDateFormat {
	if o == nil {
		return nil
	}
	return o.DateFormat
}

func (o *DocumentCreateDocumentTemporaryMeta) GetDistributionMethod() *DistributionMethodAccount {
	if o == nil {
		return nil
	}
	return o.DistributionMethod
}

func (o *DocumentCreateDocumentTemporaryMeta) GetSigningOrder() *SigningOrderAccount {
	if o == nil {
		return nil
	}
	return o.SigningOrder
}

func (o *DocumentCreateDocumentTemporaryMeta) GetRedirectURL() *string {
	if o == nil {
		return nil
	}
	return o.RedirectURL
}

func (o *DocumentCreateDocumentTemporaryMeta) GetLanguage() *DocumentCreateDocumentTemporaryLanguage {
	if o == nil {
		return nil
	}
	return o.Language
}

func (o *DocumentCreateDocumentTemporaryMeta) GetTypedSignatureEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.TypedSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryMeta) GetDrawSignatureEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.DrawSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryMeta) GetUploadSignatureEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.UploadSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryMeta) GetEmailSettings() *EmailSettingsAccount {
	if o == nil {
		return nil
	}
	return o.EmailSettings
}

type DocumentCreateDocumentTemporaryRequest struct {
	// The title of the document.
	Title string `json:"title"`
	// The external ID of the document.
	ExternalID *string `json:"externalId,omitempty"`
	// The visibility of the document.
	Visibility *VisibilityAccount `json:"visibility,omitempty"`
	// The type of authentication required for the recipient to access the document.
	GlobalAccessAuth *DocumentCreateDocumentTemporaryGlobalAccessAuthRequest `json:"globalAccessAuth,omitempty"`
	// The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
	GlobalActionAuth *GlobalActionAuthAccount             `json:"globalActionAuth,omitempty"`
	FormValues       map[string]FormValuesRequest         `json:"formValues,omitempty"`
	Recipients       []RecipientAccount                   `json:"recipients,omitempty"`
	Meta             *DocumentCreateDocumentTemporaryMeta `json:"meta,omitempty"`
}

func (o *DocumentCreateDocumentTemporaryRequest) GetTitle() string {
	if o == nil {
		return ""
	}
	return o.Title
}

func (o *DocumentCreateDocumentTemporaryRequest) GetExternalID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalID
}

func (o *DocumentCreateDocumentTemporaryRequest) GetVisibility() *VisibilityAccount {
	if o == nil {
		return nil
	}
	return o.Visibility
}

func (o *DocumentCreateDocumentTemporaryRequest) GetGlobalAccessAuth() *DocumentCreateDocumentTemporaryGlobalAccessAuthRequest {
	if o == nil {
		return nil
	}
	return o.GlobalAccessAuth
}

func (o *DocumentCreateDocumentTemporaryRequest) GetGlobalActionAuth() *GlobalActionAuthAccount {
	if o == nil {
		return nil
	}
	return o.GlobalActionAuth
}

func (o *DocumentCreateDocumentTemporaryRequest) GetFormValues() map[string]FormValuesRequest {
	if o == nil {
		return nil
	}
	return o.FormValues
}

func (o *DocumentCreateDocumentTemporaryRequest) GetRecipients() []RecipientAccount {
	if o == nil {
		return nil
	}
	return o.Recipients
}

func (o *DocumentCreateDocumentTemporaryRequest) GetMeta() *DocumentCreateDocumentTemporaryMeta {
	if o == nil {
		return nil
	}
	return o.Meta
}

type DocumentVisibility string

const (
	DocumentVisibilityEveryone        DocumentVisibility = "EVERYONE"
	DocumentVisibilityManagerAndAbove DocumentVisibility = "MANAGER_AND_ABOVE"
	DocumentVisibilityAdmin           DocumentVisibility = "ADMIN"
)

func (e DocumentVisibility) ToPointer() *DocumentVisibility {
	return &e
}
func (e *DocumentVisibility) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EVERYONE":
		fallthrough
	case "MANAGER_AND_ABOVE":
		fallthrough
	case "ADMIN":
		*e = DocumentVisibility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentVisibility: %v", v)
	}
}

type DocumentCreateDocumentTemporaryStatus string

const (
	DocumentCreateDocumentTemporaryStatusDraft     DocumentCreateDocumentTemporaryStatus = "DRAFT"
	DocumentCreateDocumentTemporaryStatusPending   DocumentCreateDocumentTemporaryStatus = "PENDING"
	DocumentCreateDocumentTemporaryStatusCompleted DocumentCreateDocumentTemporaryStatus = "COMPLETED"
	DocumentCreateDocumentTemporaryStatusRejected  DocumentCreateDocumentTemporaryStatus = "REJECTED"
)

func (e DocumentCreateDocumentTemporaryStatus) ToPointer() *DocumentCreateDocumentTemporaryStatus {
	return &e
}
func (e *DocumentCreateDocumentTemporaryStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DRAFT":
		fallthrough
	case "PENDING":
		fallthrough
	case "COMPLETED":
		fallthrough
	case "REJECTED":
		*e = DocumentCreateDocumentTemporaryStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryStatus: %v", v)
	}
}

type DocumentCreateDocumentTemporarySource string

const (
	DocumentCreateDocumentTemporarySourceDocument           DocumentCreateDocumentTemporarySource = "DOCUMENT"
	DocumentCreateDocumentTemporarySourceTemplate           DocumentCreateDocumentTemporarySource = "TEMPLATE"
	DocumentCreateDocumentTemporarySourceTemplateDirectLink DocumentCreateDocumentTemporarySource = "TEMPLATE_DIRECT_LINK"
)

func (e DocumentCreateDocumentTemporarySource) ToPointer() *DocumentCreateDocumentTemporarySource {
	return &e
}
func (e *DocumentCreateDocumentTemporarySource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DOCUMENT":
		fallthrough
	case "TEMPLATE":
		fallthrough
	case "TEMPLATE_DIRECT_LINK":
		*e = DocumentCreateDocumentTemporarySource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporarySource: %v", v)
	}
}

// DocumentGlobalAccessAuth - The type of authentication required for the recipient to access the document.
type DocumentGlobalAccessAuth string

const (
	DocumentGlobalAccessAuthAccount DocumentGlobalAccessAuth = "ACCOUNT"
)

func (e DocumentGlobalAccessAuth) ToPointer() *DocumentGlobalAccessAuth {
	return &e
}
func (e *DocumentGlobalAccessAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		*e = DocumentGlobalAccessAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentGlobalAccessAuth: %v", v)
	}
}

// DocumentGlobalActionAuth - The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
type DocumentGlobalActionAuth string

const (
	DocumentGlobalActionAuthAccount       DocumentGlobalActionAuth = "ACCOUNT"
	DocumentGlobalActionAuthPasskey       DocumentGlobalActionAuth = "PASSKEY"
	DocumentGlobalActionAuthTwoFactorAuth DocumentGlobalActionAuth = "TWO_FACTOR_AUTH"
)

func (e DocumentGlobalActionAuth) ToPointer() *DocumentGlobalActionAuth {
	return &e
}
func (e *DocumentGlobalActionAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		*e = DocumentGlobalActionAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentGlobalActionAuth: %v", v)
	}
}

type DocumentCreateDocumentTemporaryAuthOptions struct {
	// The type of authentication required for the recipient to access the document.
	GlobalAccessAuth *DocumentGlobalAccessAuth `json:"globalAccessAuth"`
	// The type of authentication required for the recipient to sign the document. This field is restricted to Enterprise plan users only.
	GlobalActionAuth *DocumentGlobalActionAuth `json:"globalActionAuth"`
}

func (o *DocumentCreateDocumentTemporaryAuthOptions) GetGlobalAccessAuth() *DocumentGlobalAccessAuth {
	if o == nil {
		return nil
	}
	return o.GlobalAccessAuth
}

func (o *DocumentCreateDocumentTemporaryAuthOptions) GetGlobalActionAuth() *DocumentGlobalActionAuth {
	if o == nil {
		return nil
	}
	return o.GlobalActionAuth
}

type DocumentFormValuesType string

const (
	DocumentFormValuesTypeStr     DocumentFormValuesType = "str"
	DocumentFormValuesTypeBoolean DocumentFormValuesType = "boolean"
	DocumentFormValuesTypeNumber  DocumentFormValuesType = "number"
)

type DocumentFormValues struct {
	Str     *string  `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`

	Type DocumentFormValuesType
}

func CreateDocumentFormValuesStr(str string) DocumentFormValues {
	typ := DocumentFormValuesTypeStr

	return DocumentFormValues{
		Str:  &str,
		Type: typ,
	}
}

func CreateDocumentFormValuesBoolean(boolean bool) DocumentFormValues {
	typ := DocumentFormValuesTypeBoolean

	return DocumentFormValues{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateDocumentFormValuesNumber(number float64) DocumentFormValues {
	typ := DocumentFormValuesTypeNumber

	return DocumentFormValues{
		Number: &number,
		Type:   typ,
	}
}

func (u *DocumentFormValues) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = DocumentFormValuesTypeStr
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, true); err == nil {
		u.Boolean = &boolean
		u.Type = DocumentFormValuesTypeBoolean
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = DocumentFormValuesTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DocumentFormValues", string(data))
}

func (u DocumentFormValues) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type DocumentFormValues: all fields are null")
}

type DocumentDocumentDataType string

const (
	DocumentDocumentDataTypeS3Path  DocumentDocumentDataType = "S3_PATH"
	DocumentDocumentDataTypeBytes   DocumentDocumentDataType = "BYTES"
	DocumentDocumentDataTypeBytes64 DocumentDocumentDataType = "BYTES_64"
)

func (e DocumentDocumentDataType) ToPointer() *DocumentDocumentDataType {
	return &e
}
func (e *DocumentDocumentDataType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "S3_PATH":
		fallthrough
	case "BYTES":
		fallthrough
	case "BYTES_64":
		*e = DocumentDocumentDataType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentDocumentDataType: %v", v)
	}
}

type DocumentCreateDocumentTemporaryDocumentData struct {
	Type        DocumentDocumentDataType `json:"type"`
	ID          string                   `json:"id"`
	Data        string                   `json:"data"`
	InitialData string                   `json:"initialData"`
}

func (o *DocumentCreateDocumentTemporaryDocumentData) GetType() DocumentDocumentDataType {
	if o == nil {
		return DocumentDocumentDataType("")
	}
	return o.Type
}

func (o *DocumentCreateDocumentTemporaryDocumentData) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *DocumentCreateDocumentTemporaryDocumentData) GetData() string {
	if o == nil {
		return ""
	}
	return o.Data
}

func (o *DocumentCreateDocumentTemporaryDocumentData) GetInitialData() string {
	if o == nil {
		return ""
	}
	return o.InitialData
}

type DocumentSigningOrder string

const (
	DocumentSigningOrderParallel   DocumentSigningOrder = "PARALLEL"
	DocumentSigningOrderSequential DocumentSigningOrder = "SEQUENTIAL"
)

func (e DocumentSigningOrder) ToPointer() *DocumentSigningOrder {
	return &e
}
func (e *DocumentSigningOrder) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PARALLEL":
		fallthrough
	case "SEQUENTIAL":
		*e = DocumentSigningOrder(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentSigningOrder: %v", v)
	}
}

type DocumentDistributionMethod string

const (
	DocumentDistributionMethodEmail DocumentDistributionMethod = "EMAIL"
	DocumentDistributionMethodNone  DocumentDistributionMethod = "NONE"
)

func (e DocumentDistributionMethod) ToPointer() *DocumentDistributionMethod {
	return &e
}
func (e *DocumentDistributionMethod) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EMAIL":
		fallthrough
	case "NONE":
		*e = DocumentDistributionMethod(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentDistributionMethod: %v", v)
	}
}

type DocumentEmailSettings struct {
	// Whether to send an email to all recipients that the document is ready for them to sign.
	RecipientSigningRequest *bool `default:"true" json:"recipientSigningRequest"`
	// Whether to send an email to the recipient who was removed from a pending document.
	RecipientRemoved *bool `default:"true" json:"recipientRemoved"`
	// Whether to send an email to the document owner when a recipient has signed the document.
	RecipientSigned *bool `default:"true" json:"recipientSigned"`
	// Whether to send an email to the recipient who has just signed the document indicating that there are still other recipients who need to sign the document. This will only be sent if the document is still pending after the recipient has signed.
	DocumentPending *bool `default:"true" json:"documentPending"`
	// Whether to send an email to all recipients when the document is complete.
	DocumentCompleted *bool `default:"true" json:"documentCompleted"`
	// Whether to send an email to all recipients if a pending document has been deleted.
	DocumentDeleted *bool `default:"true" json:"documentDeleted"`
	// Whether to send an email to the document owner when the document is complete.
	OwnerDocumentCompleted *bool `default:"true" json:"ownerDocumentCompleted"`
}

func (d DocumentEmailSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DocumentEmailSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *DocumentEmailSettings) GetRecipientSigningRequest() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientSigningRequest
}

func (o *DocumentEmailSettings) GetRecipientRemoved() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientRemoved
}

func (o *DocumentEmailSettings) GetRecipientSigned() *bool {
	if o == nil {
		return nil
	}
	return o.RecipientSigned
}

func (o *DocumentEmailSettings) GetDocumentPending() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentPending
}

func (o *DocumentEmailSettings) GetDocumentCompleted() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentCompleted
}

func (o *DocumentEmailSettings) GetDocumentDeleted() *bool {
	if o == nil {
		return nil
	}
	return o.DocumentDeleted
}

func (o *DocumentEmailSettings) GetOwnerDocumentCompleted() *bool {
	if o == nil {
		return nil
	}
	return o.OwnerDocumentCompleted
}

type DocumentCreateDocumentTemporaryDocumentMeta struct {
	SigningOrder           DocumentSigningOrder       `json:"signingOrder"`
	DistributionMethod     DocumentDistributionMethod `json:"distributionMethod"`
	ID                     string                     `json:"id"`
	Subject                *string                    `json:"subject"`
	Message                *string                    `json:"message"`
	Timezone               *string                    `json:"timezone"`
	Password               *string                    `json:"password"`
	DateFormat             *string                    `json:"dateFormat"`
	DocumentID             float64                    `json:"documentId"`
	RedirectURL            *string                    `json:"redirectUrl"`
	TypedSignatureEnabled  bool                       `json:"typedSignatureEnabled"`
	UploadSignatureEnabled bool                       `json:"uploadSignatureEnabled"`
	DrawSignatureEnabled   bool                       `json:"drawSignatureEnabled"`
	AllowDictateNextSigner bool                       `json:"allowDictateNextSigner"`
	Language               string                     `json:"language"`
	EmailSettings          *DocumentEmailSettings     `json:"emailSettings"`
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetSigningOrder() DocumentSigningOrder {
	if o == nil {
		return DocumentSigningOrder("")
	}
	return o.SigningOrder
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetDistributionMethod() DocumentDistributionMethod {
	if o == nil {
		return DocumentDistributionMethod("")
	}
	return o.DistributionMethod
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetSubject() *string {
	if o == nil {
		return nil
	}
	return o.Subject
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetTimezone() *string {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetPassword() *string {
	if o == nil {
		return nil
	}
	return o.Password
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetDateFormat() *string {
	if o == nil {
		return nil
	}
	return o.DateFormat
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetDocumentID() float64 {
	if o == nil {
		return 0.0
	}
	return o.DocumentID
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetRedirectURL() *string {
	if o == nil {
		return nil
	}
	return o.RedirectURL
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetTypedSignatureEnabled() bool {
	if o == nil {
		return false
	}
	return o.TypedSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetUploadSignatureEnabled() bool {
	if o == nil {
		return false
	}
	return o.UploadSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetDrawSignatureEnabled() bool {
	if o == nil {
		return false
	}
	return o.DrawSignatureEnabled
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetAllowDictateNextSigner() bool {
	if o == nil {
		return false
	}
	return o.AllowDictateNextSigner
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetLanguage() string {
	if o == nil {
		return ""
	}
	return o.Language
}

func (o *DocumentCreateDocumentTemporaryDocumentMeta) GetEmailSettings() *DocumentEmailSettings {
	if o == nil {
		return nil
	}
	return o.EmailSettings
}

type DocumentRole string

const (
	DocumentRoleCc        DocumentRole = "CC"
	DocumentRoleSigner    DocumentRole = "SIGNER"
	DocumentRoleViewer    DocumentRole = "VIEWER"
	DocumentRoleApprover  DocumentRole = "APPROVER"
	DocumentRoleAssistant DocumentRole = "ASSISTANT"
)

func (e DocumentRole) ToPointer() *DocumentRole {
	return &e
}
func (e *DocumentRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CC":
		fallthrough
	case "SIGNER":
		fallthrough
	case "VIEWER":
		fallthrough
	case "APPROVER":
		fallthrough
	case "ASSISTANT":
		*e = DocumentRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentRole: %v", v)
	}
}

type DocumentCreateDocumentTemporaryReadStatus string

const (
	DocumentCreateDocumentTemporaryReadStatusNotOpened DocumentCreateDocumentTemporaryReadStatus = "NOT_OPENED"
	DocumentCreateDocumentTemporaryReadStatusOpened    DocumentCreateDocumentTemporaryReadStatus = "OPENED"
)

func (e DocumentCreateDocumentTemporaryReadStatus) ToPointer() *DocumentCreateDocumentTemporaryReadStatus {
	return &e
}
func (e *DocumentCreateDocumentTemporaryReadStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NOT_OPENED":
		fallthrough
	case "OPENED":
		*e = DocumentCreateDocumentTemporaryReadStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporaryReadStatus: %v", v)
	}
}

type DocumentCreateDocumentTemporarySigningStatus string

const (
	DocumentCreateDocumentTemporarySigningStatusNotSigned DocumentCreateDocumentTemporarySigningStatus = "NOT_SIGNED"
	DocumentCreateDocumentTemporarySigningStatusSigned    DocumentCreateDocumentTemporarySigningStatus = "SIGNED"
	DocumentCreateDocumentTemporarySigningStatusRejected  DocumentCreateDocumentTemporarySigningStatus = "REJECTED"
)

func (e DocumentCreateDocumentTemporarySigningStatus) ToPointer() *DocumentCreateDocumentTemporarySigningStatus {
	return &e
}
func (e *DocumentCreateDocumentTemporarySigningStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NOT_SIGNED":
		fallthrough
	case "SIGNED":
		fallthrough
	case "REJECTED":
		*e = DocumentCreateDocumentTemporarySigningStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporarySigningStatus: %v", v)
	}
}

type DocumentCreateDocumentTemporarySendStatus string

const (
	DocumentCreateDocumentTemporarySendStatusNotSent DocumentCreateDocumentTemporarySendStatus = "NOT_SENT"
	DocumentCreateDocumentTemporarySendStatusSent    DocumentCreateDocumentTemporarySendStatus = "SENT"
)

func (e DocumentCreateDocumentTemporarySendStatus) ToPointer() *DocumentCreateDocumentTemporarySendStatus {
	return &e
}
func (e *DocumentCreateDocumentTemporarySendStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NOT_SENT":
		fallthrough
	case "SENT":
		*e = DocumentCreateDocumentTemporarySendStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentCreateDocumentTemporarySendStatus: %v", v)
	}
}

// DocumentAccessAuth - The type of authentication required for the recipient to access the document.
type DocumentAccessAuth string

const (
	DocumentAccessAuthAccount DocumentAccessAuth = "ACCOUNT"
)

func (e DocumentAccessAuth) ToPointer() *DocumentAccessAuth {
	return &e
}
func (e *DocumentAccessAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		*e = DocumentAccessAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentAccessAuth: %v", v)
	}
}

// DocumentActionAuth - The type of authentication required for the recipient to sign the document.
type DocumentActionAuth string

const (
	DocumentActionAuthAccount       DocumentActionAuth = "ACCOUNT"
	DocumentActionAuthPasskey       DocumentActionAuth = "PASSKEY"
	DocumentActionAuthTwoFactorAuth DocumentActionAuth = "TWO_FACTOR_AUTH"
	DocumentActionAuthExplicitNone  DocumentActionAuth = "EXPLICIT_NONE"
)

func (e DocumentActionAuth) ToPointer() *DocumentActionAuth {
	return &e
}
func (e *DocumentActionAuth) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ACCOUNT":
		fallthrough
	case "PASSKEY":
		fallthrough
	case "TWO_FACTOR_AUTH":
		fallthrough
	case "EXPLICIT_NONE":
		*e = DocumentActionAuth(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentActionAuth: %v", v)
	}
}

type DocumentCreateDocumentTemporaryRecipientAuthOptions struct {
	// The type of authentication required for the recipient to access the document.
	AccessAuth *DocumentAccessAuth `json:"accessAuth"`
	// The type of authentication required for the recipient to sign the document.
	ActionAuth *DocumentActionAuth `json:"actionAuth"`
}

func (o *DocumentCreateDocumentTemporaryRecipientAuthOptions) GetAccessAuth() *DocumentAccessAuth {
	if o == nil {
		return nil
	}
	return o.AccessAuth
}

func (o *DocumentCreateDocumentTemporaryRecipientAuthOptions) GetActionAuth() *DocumentActionAuth {
	if o == nil {
		return nil
	}
	return o.ActionAuth
}

type DocumentRecipient struct {
	Role              DocumentRole                                         `json:"role"`
	ReadStatus        DocumentCreateDocumentTemporaryReadStatus            `json:"readStatus"`
	SigningStatus     DocumentCreateDocumentTemporarySigningStatus         `json:"signingStatus"`
	SendStatus        DocumentCreateDocumentTemporarySendStatus            `json:"sendStatus"`
	ID                float64                                              `json:"id"`
	DocumentID        *float64                                             `json:"documentId"`
	TemplateID        *float64                                             `json:"templateId"`
	Email             string                                               `json:"email"`
	Name              string                                               `json:"name"`
	Token             string                                               `json:"token"`
	DocumentDeletedAt *string                                              `json:"documentDeletedAt"`
	Expired           *string                                              `json:"expired"`
	SignedAt          *string                                              `json:"signedAt"`
	AuthOptions       *DocumentCreateDocumentTemporaryRecipientAuthOptions `json:"authOptions"`
	// The order in which the recipient should sign the document. Only works if the document is set to sequential signing.
	SigningOrder    *float64 `json:"signingOrder"`
	RejectionReason *string  `json:"rejectionReason"`
}

func (o *DocumentRecipient) GetRole() DocumentRole {
	if o == nil {
		return DocumentRole("")
	}
	return o.Role
}

func (o *DocumentRecipient) GetReadStatus() DocumentCreateDocumentTemporaryReadStatus {
	if o == nil {
		return DocumentCreateDocumentTemporaryReadStatus("")
	}
	return o.ReadStatus
}

func (o *DocumentRecipient) GetSigningStatus() DocumentCreateDocumentTemporarySigningStatus {
	if o == nil {
		return DocumentCreateDocumentTemporarySigningStatus("")
	}
	return o.SigningStatus
}

func (o *DocumentRecipient) GetSendStatus() DocumentCreateDocumentTemporarySendStatus {
	if o == nil {
		return DocumentCreateDocumentTemporarySendStatus("")
	}
	return o.SendStatus
}

func (o *DocumentRecipient) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *DocumentRecipient) GetDocumentID() *float64 {
	if o == nil {
		return nil
	}
	return o.DocumentID
}

func (o *DocumentRecipient) GetTemplateID() *float64 {
	if o == nil {
		return nil
	}
	return o.TemplateID
}

func (o *DocumentRecipient) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *DocumentRecipient) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DocumentRecipient) GetToken() string {
	if o == nil {
		return ""
	}
	return o.Token
}

func (o *DocumentRecipient) GetDocumentDeletedAt() *string {
	if o == nil {
		return nil
	}
	return o.DocumentDeletedAt
}

func (o *DocumentRecipient) GetExpired() *string {
	if o == nil {
		return nil
	}
	return o.Expired
}

func (o *DocumentRecipient) GetSignedAt() *string {
	if o == nil {
		return nil
	}
	return o.SignedAt
}

func (o *DocumentRecipient) GetAuthOptions() *DocumentCreateDocumentTemporaryRecipientAuthOptions {
	if o == nil {
		return nil
	}
	return o.AuthOptions
}

func (o *DocumentRecipient) GetSigningOrder() *float64 {
	if o == nil {
		return nil
	}
	return o.SigningOrder
}

func (o *DocumentRecipient) GetRejectionReason() *string {
	if o == nil {
		return nil
	}
	return o.RejectionReason
}

type DocumentFieldType string

const (
	DocumentFieldTypeSignature     DocumentFieldType = "SIGNATURE"
	DocumentFieldTypeFreeSignature DocumentFieldType = "FREE_SIGNATURE"
	DocumentFieldTypeInitials      DocumentFieldType = "INITIALS"
	DocumentFieldTypeName          DocumentFieldType = "NAME"
	DocumentFieldTypeEmail         DocumentFieldType = "EMAIL"
	DocumentFieldTypeDate          DocumentFieldType = "DATE"
	DocumentFieldTypeText          DocumentFieldType = "TEXT"
	DocumentFieldTypeNumber        DocumentFieldType = "NUMBER"
	DocumentFieldTypeRadio         DocumentFieldType = "RADIO"
	DocumentFieldTypeCheckbox      DocumentFieldType = "CHECKBOX"
	DocumentFieldTypeDropdown      DocumentFieldType = "DROPDOWN"
)

func (e DocumentFieldType) ToPointer() *DocumentFieldType {
	return &e
}
func (e *DocumentFieldType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SIGNATURE":
		fallthrough
	case "FREE_SIGNATURE":
		fallthrough
	case "INITIALS":
		fallthrough
	case "NAME":
		fallthrough
	case "EMAIL":
		fallthrough
	case "DATE":
		fallthrough
	case "TEXT":
		fallthrough
	case "NUMBER":
		fallthrough
	case "RADIO":
		fallthrough
	case "CHECKBOX":
		fallthrough
	case "DROPDOWN":
		*e = DocumentFieldType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentFieldType: %v", v)
	}
}

type DocumentTypeDropdown string

const (
	DocumentTypeDropdownDropdown DocumentTypeDropdown = "dropdown"
)

func (e DocumentTypeDropdown) ToPointer() *DocumentTypeDropdown {
	return &e
}
func (e *DocumentTypeDropdown) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "dropdown":
		*e = DocumentTypeDropdown(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeDropdown: %v", v)
	}
}

type DocumentValue3 struct {
	Value string `json:"value"`
}

func (o *DocumentValue3) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaDocumentDropdown struct {
	Label        *string              `json:"label,omitempty"`
	Placeholder  *string              `json:"placeholder,omitempty"`
	Required     *bool                `json:"required,omitempty"`
	ReadOnly     *bool                `json:"readOnly,omitempty"`
	Type         DocumentTypeDropdown `json:"type"`
	Values       []DocumentValue3     `json:"values,omitempty"`
	DefaultValue *string              `json:"defaultValue,omitempty"`
}

func (o *FieldMetaDocumentDropdown) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentDropdown) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentDropdown) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentDropdown) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentDropdown) GetType() DocumentTypeDropdown {
	if o == nil {
		return DocumentTypeDropdown("")
	}
	return o.Type
}

func (o *FieldMetaDocumentDropdown) GetValues() []DocumentValue3 {
	if o == nil {
		return nil
	}
	return o.Values
}

func (o *FieldMetaDocumentDropdown) GetDefaultValue() *string {
	if o == nil {
		return nil
	}
	return o.DefaultValue
}

type DocumentTypeCheckbox string

const (
	DocumentTypeCheckboxCheckbox DocumentTypeCheckbox = "checkbox"
)

func (e DocumentTypeCheckbox) ToPointer() *DocumentTypeCheckbox {
	return &e
}
func (e *DocumentTypeCheckbox) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "checkbox":
		*e = DocumentTypeCheckbox(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeCheckbox: %v", v)
	}
}

type DocumentValue2 struct {
	ID      float64 `json:"id"`
	Checked bool    `json:"checked"`
	Value   string  `json:"value"`
}

func (o *DocumentValue2) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *DocumentValue2) GetChecked() bool {
	if o == nil {
		return false
	}
	return o.Checked
}

func (o *DocumentValue2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaDocumentCheckbox struct {
	Label            *string              `json:"label,omitempty"`
	Placeholder      *string              `json:"placeholder,omitempty"`
	Required         *bool                `json:"required,omitempty"`
	ReadOnly         *bool                `json:"readOnly,omitempty"`
	Type             DocumentTypeCheckbox `json:"type"`
	Values           []DocumentValue2     `json:"values,omitempty"`
	ValidationRule   *string              `json:"validationRule,omitempty"`
	ValidationLength *float64             `json:"validationLength,omitempty"`
}

func (o *FieldMetaDocumentCheckbox) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentCheckbox) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentCheckbox) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentCheckbox) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentCheckbox) GetType() DocumentTypeCheckbox {
	if o == nil {
		return DocumentTypeCheckbox("")
	}
	return o.Type
}

func (o *FieldMetaDocumentCheckbox) GetValues() []DocumentValue2 {
	if o == nil {
		return nil
	}
	return o.Values
}

func (o *FieldMetaDocumentCheckbox) GetValidationRule() *string {
	if o == nil {
		return nil
	}
	return o.ValidationRule
}

func (o *FieldMetaDocumentCheckbox) GetValidationLength() *float64 {
	if o == nil {
		return nil
	}
	return o.ValidationLength
}

type DocumentTypeRadio string

const (
	DocumentTypeRadioRadio DocumentTypeRadio = "radio"
)

func (e DocumentTypeRadio) ToPointer() *DocumentTypeRadio {
	return &e
}
func (e *DocumentTypeRadio) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "radio":
		*e = DocumentTypeRadio(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeRadio: %v", v)
	}
}

type DocumentValue1 struct {
	ID      float64 `json:"id"`
	Checked bool    `json:"checked"`
	Value   string  `json:"value"`
}

func (o *DocumentValue1) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *DocumentValue1) GetChecked() bool {
	if o == nil {
		return false
	}
	return o.Checked
}

func (o *DocumentValue1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FieldMetaDocumentRadio struct {
	Label       *string           `json:"label,omitempty"`
	Placeholder *string           `json:"placeholder,omitempty"`
	Required    *bool             `json:"required,omitempty"`
	ReadOnly    *bool             `json:"readOnly,omitempty"`
	Type        DocumentTypeRadio `json:"type"`
	Values      []DocumentValue1  `json:"values,omitempty"`
}

func (o *FieldMetaDocumentRadio) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentRadio) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentRadio) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentRadio) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentRadio) GetType() DocumentTypeRadio {
	if o == nil {
		return DocumentTypeRadio("")
	}
	return o.Type
}

func (o *FieldMetaDocumentRadio) GetValues() []DocumentValue1 {
	if o == nil {
		return nil
	}
	return o.Values
}

type DocumentTypeNumber string

const (
	DocumentTypeNumberNumber DocumentTypeNumber = "number"
)

func (e DocumentTypeNumber) ToPointer() *DocumentTypeNumber {
	return &e
}
func (e *DocumentTypeNumber) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "number":
		*e = DocumentTypeNumber(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeNumber: %v", v)
	}
}

type DocumentTextAlign6 string

const (
	DocumentTextAlign6Left   DocumentTextAlign6 = "left"
	DocumentTextAlign6Center DocumentTextAlign6 = "center"
	DocumentTextAlign6Right  DocumentTextAlign6 = "right"
)

func (e DocumentTextAlign6) ToPointer() *DocumentTextAlign6 {
	return &e
}
func (e *DocumentTextAlign6) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign6(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign6: %v", v)
	}
}

type FieldMetaDocumentNumber struct {
	Label        *string             `json:"label,omitempty"`
	Placeholder  *string             `json:"placeholder,omitempty"`
	Required     *bool               `json:"required,omitempty"`
	ReadOnly     *bool               `json:"readOnly,omitempty"`
	Type         DocumentTypeNumber  `json:"type"`
	NumberFormat *string             `json:"numberFormat,omitempty"`
	Value        *string             `json:"value,omitempty"`
	MinValue     *float64            `json:"minValue,omitempty"`
	MaxValue     *float64            `json:"maxValue,omitempty"`
	FontSize     *float64            `json:"fontSize,omitempty"`
	TextAlign    *DocumentTextAlign6 `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentNumber) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentNumber) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentNumber) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentNumber) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentNumber) GetType() DocumentTypeNumber {
	if o == nil {
		return DocumentTypeNumber("")
	}
	return o.Type
}

func (o *FieldMetaDocumentNumber) GetNumberFormat() *string {
	if o == nil {
		return nil
	}
	return o.NumberFormat
}

func (o *FieldMetaDocumentNumber) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *FieldMetaDocumentNumber) GetMinValue() *float64 {
	if o == nil {
		return nil
	}
	return o.MinValue
}

func (o *FieldMetaDocumentNumber) GetMaxValue() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxValue
}

func (o *FieldMetaDocumentNumber) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentNumber) GetTextAlign() *DocumentTextAlign6 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentTypeText string

const (
	DocumentTypeTextText DocumentTypeText = "text"
)

func (e DocumentTypeText) ToPointer() *DocumentTypeText {
	return &e
}
func (e *DocumentTypeText) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "text":
		*e = DocumentTypeText(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeText: %v", v)
	}
}

type DocumentTextAlign5 string

const (
	DocumentTextAlign5Left   DocumentTextAlign5 = "left"
	DocumentTextAlign5Center DocumentTextAlign5 = "center"
	DocumentTextAlign5Right  DocumentTextAlign5 = "right"
)

func (e DocumentTextAlign5) ToPointer() *DocumentTextAlign5 {
	return &e
}
func (e *DocumentTextAlign5) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign5(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign5: %v", v)
	}
}

type FieldMetaDocumentText struct {
	Label          *string             `json:"label,omitempty"`
	Placeholder    *string             `json:"placeholder,omitempty"`
	Required       *bool               `json:"required,omitempty"`
	ReadOnly       *bool               `json:"readOnly,omitempty"`
	Type           DocumentTypeText    `json:"type"`
	Text           *string             `json:"text,omitempty"`
	CharacterLimit *float64            `json:"characterLimit,omitempty"`
	FontSize       *float64            `json:"fontSize,omitempty"`
	TextAlign      *DocumentTextAlign5 `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentText) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentText) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentText) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentText) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentText) GetType() DocumentTypeText {
	if o == nil {
		return DocumentTypeText("")
	}
	return o.Type
}

func (o *FieldMetaDocumentText) GetText() *string {
	if o == nil {
		return nil
	}
	return o.Text
}

func (o *FieldMetaDocumentText) GetCharacterLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.CharacterLimit
}

func (o *FieldMetaDocumentText) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentText) GetTextAlign() *DocumentTextAlign5 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentTypeDate string

const (
	DocumentTypeDateDate DocumentTypeDate = "date"
)

func (e DocumentTypeDate) ToPointer() *DocumentTypeDate {
	return &e
}
func (e *DocumentTypeDate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "date":
		*e = DocumentTypeDate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeDate: %v", v)
	}
}

type DocumentTextAlign4 string

const (
	DocumentTextAlign4Left   DocumentTextAlign4 = "left"
	DocumentTextAlign4Center DocumentTextAlign4 = "center"
	DocumentTextAlign4Right  DocumentTextAlign4 = "right"
)

func (e DocumentTextAlign4) ToPointer() *DocumentTextAlign4 {
	return &e
}
func (e *DocumentTextAlign4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign4: %v", v)
	}
}

type FieldMetaDocumentDate struct {
	Label       *string             `json:"label,omitempty"`
	Placeholder *string             `json:"placeholder,omitempty"`
	Required    *bool               `json:"required,omitempty"`
	ReadOnly    *bool               `json:"readOnly,omitempty"`
	Type        DocumentTypeDate    `json:"type"`
	FontSize    *float64            `json:"fontSize,omitempty"`
	TextAlign   *DocumentTextAlign4 `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentDate) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentDate) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentDate) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentDate) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentDate) GetType() DocumentTypeDate {
	if o == nil {
		return DocumentTypeDate("")
	}
	return o.Type
}

func (o *FieldMetaDocumentDate) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentDate) GetTextAlign() *DocumentTextAlign4 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentTypeEmail string

const (
	DocumentTypeEmailEmail DocumentTypeEmail = "email"
)

func (e DocumentTypeEmail) ToPointer() *DocumentTypeEmail {
	return &e
}
func (e *DocumentTypeEmail) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "email":
		*e = DocumentTypeEmail(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeEmail: %v", v)
	}
}

type DocumentTextAlign3 string

const (
	DocumentTextAlign3Left   DocumentTextAlign3 = "left"
	DocumentTextAlign3Center DocumentTextAlign3 = "center"
	DocumentTextAlign3Right  DocumentTextAlign3 = "right"
)

func (e DocumentTextAlign3) ToPointer() *DocumentTextAlign3 {
	return &e
}
func (e *DocumentTextAlign3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign3: %v", v)
	}
}

type FieldMetaDocumentEmail struct {
	Label       *string             `json:"label,omitempty"`
	Placeholder *string             `json:"placeholder,omitempty"`
	Required    *bool               `json:"required,omitempty"`
	ReadOnly    *bool               `json:"readOnly,omitempty"`
	Type        DocumentTypeEmail   `json:"type"`
	FontSize    *float64            `json:"fontSize,omitempty"`
	TextAlign   *DocumentTextAlign3 `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentEmail) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentEmail) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentEmail) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentEmail) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentEmail) GetType() DocumentTypeEmail {
	if o == nil {
		return DocumentTypeEmail("")
	}
	return o.Type
}

func (o *FieldMetaDocumentEmail) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentEmail) GetTextAlign() *DocumentTextAlign3 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentTypeName string

const (
	DocumentTypeNameName DocumentTypeName = "name"
)

func (e DocumentTypeName) ToPointer() *DocumentTypeName {
	return &e
}
func (e *DocumentTypeName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "name":
		*e = DocumentTypeName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeName: %v", v)
	}
}

type DocumentTextAlign2 string

const (
	DocumentTextAlign2Left   DocumentTextAlign2 = "left"
	DocumentTextAlign2Center DocumentTextAlign2 = "center"
	DocumentTextAlign2Right  DocumentTextAlign2 = "right"
)

func (e DocumentTextAlign2) ToPointer() *DocumentTextAlign2 {
	return &e
}
func (e *DocumentTextAlign2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign2: %v", v)
	}
}

type FieldMetaDocumentName struct {
	Label       *string             `json:"label,omitempty"`
	Placeholder *string             `json:"placeholder,omitempty"`
	Required    *bool               `json:"required,omitempty"`
	ReadOnly    *bool               `json:"readOnly,omitempty"`
	Type        DocumentTypeName    `json:"type"`
	FontSize    *float64            `json:"fontSize,omitempty"`
	TextAlign   *DocumentTextAlign2 `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentName) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentName) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentName) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentName) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentName) GetType() DocumentTypeName {
	if o == nil {
		return DocumentTypeName("")
	}
	return o.Type
}

func (o *FieldMetaDocumentName) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentName) GetTextAlign() *DocumentTextAlign2 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentTypeInitials string

const (
	DocumentTypeInitialsInitials DocumentTypeInitials = "initials"
)

func (e DocumentTypeInitials) ToPointer() *DocumentTypeInitials {
	return &e
}
func (e *DocumentTypeInitials) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "initials":
		*e = DocumentTypeInitials(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTypeInitials: %v", v)
	}
}

type DocumentTextAlign1 string

const (
	DocumentTextAlign1Left   DocumentTextAlign1 = "left"
	DocumentTextAlign1Center DocumentTextAlign1 = "center"
	DocumentTextAlign1Right  DocumentTextAlign1 = "right"
)

func (e DocumentTextAlign1) ToPointer() *DocumentTextAlign1 {
	return &e
}
func (e *DocumentTextAlign1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "left":
		fallthrough
	case "center":
		fallthrough
	case "right":
		*e = DocumentTextAlign1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DocumentTextAlign1: %v", v)
	}
}

type FieldMetaDocumentInitials struct {
	Label       *string              `json:"label,omitempty"`
	Placeholder *string              `json:"placeholder,omitempty"`
	Required    *bool                `json:"required,omitempty"`
	ReadOnly    *bool                `json:"readOnly,omitempty"`
	Type        DocumentTypeInitials `json:"type"`
	FontSize    *float64             `json:"fontSize,omitempty"`
	TextAlign   *DocumentTextAlign1  `json:"textAlign,omitempty"`
}

func (o *FieldMetaDocumentInitials) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FieldMetaDocumentInitials) GetPlaceholder() *string {
	if o == nil {
		return nil
	}
	return o.Placeholder
}

func (o *FieldMetaDocumentInitials) GetRequired() *bool {
	if o == nil {
		return nil
	}
	return o.Required
}

func (o *FieldMetaDocumentInitials) GetReadOnly() *bool {
	if o == nil {
		return nil
	}
	return o.ReadOnly
}

func (o *FieldMetaDocumentInitials) GetType() DocumentTypeInitials {
	if o == nil {
		return DocumentTypeInitials("")
	}
	return o.Type
}

func (o *FieldMetaDocumentInitials) GetFontSize() *float64 {
	if o == nil {
		return nil
	}
	return o.FontSize
}

func (o *FieldMetaDocumentInitials) GetTextAlign() *DocumentTextAlign1 {
	if o == nil {
		return nil
	}
	return o.TextAlign
}

type DocumentFieldMetaUnionType string

const (
	DocumentFieldMetaUnionTypeFieldMetaDocumentInitials DocumentFieldMetaUnionType = "fieldMeta_document_Initials"
	DocumentFieldMetaUnionTypeFieldMetaDocumentName     DocumentFieldMetaUnionType = "fieldMeta_document_Name"
	DocumentFieldMetaUnionTypeFieldMetaDocumentEmail    DocumentFieldMetaUnionType = "fieldMeta_document_Email"
	DocumentFieldMetaUnionTypeFieldMetaDocumentDate     DocumentFieldMetaUnionType = "fieldMeta_document_Date"
	DocumentFieldMetaUnionTypeFieldMetaDocumentText     DocumentFieldMetaUnionType = "fieldMeta_document_Text"
	DocumentFieldMetaUnionTypeFieldMetaDocumentNumber   DocumentFieldMetaUnionType = "fieldMeta_document_Number"
	DocumentFieldMetaUnionTypeFieldMetaDocumentRadio    DocumentFieldMetaUnionType = "fieldMeta_document_Radio"
	DocumentFieldMetaUnionTypeFieldMetaDocumentCheckbox DocumentFieldMetaUnionType = "fieldMeta_document_Checkbox"
	DocumentFieldMetaUnionTypeFieldMetaDocumentDropdown DocumentFieldMetaUnionType = "fieldMeta_document_Dropdown"
)

type DocumentFieldMetaUnion struct {
	FieldMetaDocumentInitials *FieldMetaDocumentInitials `queryParam:"inline"`
	FieldMetaDocumentName     *FieldMetaDocumentName     `queryParam:"inline"`
	FieldMetaDocumentEmail    *FieldMetaDocumentEmail    `queryParam:"inline"`
	FieldMetaDocumentDate     *FieldMetaDocumentDate     `queryParam:"inline"`
	FieldMetaDocumentText     *FieldMetaDocumentText     `queryParam:"inline"`
	FieldMetaDocumentNumber   *FieldMetaDocumentNumber   `queryParam:"inline"`
	FieldMetaDocumentRadio    *FieldMetaDocumentRadio    `queryParam:"inline"`
	FieldMetaDocumentCheckbox *FieldMetaDocumentCheckbox `queryParam:"inline"`
	FieldMetaDocumentDropdown *FieldMetaDocumentDropdown `queryParam:"inline"`

	Type DocumentFieldMetaUnionType
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentInitials(fieldMetaDocumentInitials FieldMetaDocumentInitials) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentInitials

	return DocumentFieldMetaUnion{
		FieldMetaDocumentInitials: &fieldMetaDocumentInitials,
		Type:                      typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentName(fieldMetaDocumentName FieldMetaDocumentName) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentName

	return DocumentFieldMetaUnion{
		FieldMetaDocumentName: &fieldMetaDocumentName,
		Type:                  typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentEmail(fieldMetaDocumentEmail FieldMetaDocumentEmail) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentEmail

	return DocumentFieldMetaUnion{
		FieldMetaDocumentEmail: &fieldMetaDocumentEmail,
		Type:                   typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentDate(fieldMetaDocumentDate FieldMetaDocumentDate) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentDate

	return DocumentFieldMetaUnion{
		FieldMetaDocumentDate: &fieldMetaDocumentDate,
		Type:                  typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentText(fieldMetaDocumentText FieldMetaDocumentText) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentText

	return DocumentFieldMetaUnion{
		FieldMetaDocumentText: &fieldMetaDocumentText,
		Type:                  typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentNumber(fieldMetaDocumentNumber FieldMetaDocumentNumber) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentNumber

	return DocumentFieldMetaUnion{
		FieldMetaDocumentNumber: &fieldMetaDocumentNumber,
		Type:                    typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentRadio(fieldMetaDocumentRadio FieldMetaDocumentRadio) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentRadio

	return DocumentFieldMetaUnion{
		FieldMetaDocumentRadio: &fieldMetaDocumentRadio,
		Type:                   typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentCheckbox(fieldMetaDocumentCheckbox FieldMetaDocumentCheckbox) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentCheckbox

	return DocumentFieldMetaUnion{
		FieldMetaDocumentCheckbox: &fieldMetaDocumentCheckbox,
		Type:                      typ,
	}
}

func CreateDocumentFieldMetaUnionFieldMetaDocumentDropdown(fieldMetaDocumentDropdown FieldMetaDocumentDropdown) DocumentFieldMetaUnion {
	typ := DocumentFieldMetaUnionTypeFieldMetaDocumentDropdown

	return DocumentFieldMetaUnion{
		FieldMetaDocumentDropdown: &fieldMetaDocumentDropdown,
		Type:                      typ,
	}
}

func (u *DocumentFieldMetaUnion) UnmarshalJSON(data []byte) error {

	var fieldMetaDocumentRadio FieldMetaDocumentRadio = FieldMetaDocumentRadio{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentRadio, "", true, true); err == nil {
		u.FieldMetaDocumentRadio = &fieldMetaDocumentRadio
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentRadio
		return nil
	}

	var fieldMetaDocumentInitials FieldMetaDocumentInitials = FieldMetaDocumentInitials{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentInitials, "", true, true); err == nil {
		u.FieldMetaDocumentInitials = &fieldMetaDocumentInitials
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentInitials
		return nil
	}

	var fieldMetaDocumentName FieldMetaDocumentName = FieldMetaDocumentName{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentName, "", true, true); err == nil {
		u.FieldMetaDocumentName = &fieldMetaDocumentName
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentName
		return nil
	}

	var fieldMetaDocumentEmail FieldMetaDocumentEmail = FieldMetaDocumentEmail{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentEmail, "", true, true); err == nil {
		u.FieldMetaDocumentEmail = &fieldMetaDocumentEmail
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentEmail
		return nil
	}

	var fieldMetaDocumentDate FieldMetaDocumentDate = FieldMetaDocumentDate{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentDate, "", true, true); err == nil {
		u.FieldMetaDocumentDate = &fieldMetaDocumentDate
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentDate
		return nil
	}

	var fieldMetaDocumentDropdown FieldMetaDocumentDropdown = FieldMetaDocumentDropdown{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentDropdown, "", true, true); err == nil {
		u.FieldMetaDocumentDropdown = &fieldMetaDocumentDropdown
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentDropdown
		return nil
	}

	var fieldMetaDocumentCheckbox FieldMetaDocumentCheckbox = FieldMetaDocumentCheckbox{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentCheckbox, "", true, true); err == nil {
		u.FieldMetaDocumentCheckbox = &fieldMetaDocumentCheckbox
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentCheckbox
		return nil
	}

	var fieldMetaDocumentText FieldMetaDocumentText = FieldMetaDocumentText{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentText, "", true, true); err == nil {
		u.FieldMetaDocumentText = &fieldMetaDocumentText
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentText
		return nil
	}

	var fieldMetaDocumentNumber FieldMetaDocumentNumber = FieldMetaDocumentNumber{}
	if err := utils.UnmarshalJSON(data, &fieldMetaDocumentNumber, "", true, true); err == nil {
		u.FieldMetaDocumentNumber = &fieldMetaDocumentNumber
		u.Type = DocumentFieldMetaUnionTypeFieldMetaDocumentNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DocumentFieldMetaUnion", string(data))
}

func (u DocumentFieldMetaUnion) MarshalJSON() ([]byte, error) {
	if u.FieldMetaDocumentInitials != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentInitials, "", true)
	}

	if u.FieldMetaDocumentName != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentName, "", true)
	}

	if u.FieldMetaDocumentEmail != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentEmail, "", true)
	}

	if u.FieldMetaDocumentDate != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentDate, "", true)
	}

	if u.FieldMetaDocumentText != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentText, "", true)
	}

	if u.FieldMetaDocumentNumber != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentNumber, "", true)
	}

	if u.FieldMetaDocumentRadio != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentRadio, "", true)
	}

	if u.FieldMetaDocumentCheckbox != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentCheckbox, "", true)
	}

	if u.FieldMetaDocumentDropdown != nil {
		return utils.MarshalJSON(u.FieldMetaDocumentDropdown, "", true)
	}

	return nil, errors.New("could not marshal union type DocumentFieldMetaUnion: all fields are null")
}

type DocumentField struct {
	Type        DocumentFieldType `json:"type"`
	ID          float64           `json:"id"`
	SecondaryID string            `json:"secondaryId"`
	DocumentID  *float64          `json:"documentId"`
	TemplateID  *float64          `json:"templateId"`
	RecipientID float64           `json:"recipientId"`
	// The page number of the field on the document. Starts from 1.
	Page       float64                 `json:"page"`
	PositionX  any                     `json:"positionX,omitempty"`
	PositionY  any                     `json:"positionY,omitempty"`
	Width      any                     `json:"width,omitempty"`
	Height     any                     `json:"height,omitempty"`
	CustomText string                  `json:"customText"`
	Inserted   bool                    `json:"inserted"`
	FieldMeta  *DocumentFieldMetaUnion `json:"fieldMeta"`
}

func (o *DocumentField) GetType() DocumentFieldType {
	if o == nil {
		return DocumentFieldType("")
	}
	return o.Type
}

func (o *DocumentField) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *DocumentField) GetSecondaryID() string {
	if o == nil {
		return ""
	}
	return o.SecondaryID
}

func (o *DocumentField) GetDocumentID() *float64 {
	if o == nil {
		return nil
	}
	return o.DocumentID
}

func (o *DocumentField) GetTemplateID() *float64 {
	if o == nil {
		return nil
	}
	return o.TemplateID
}

func (o *DocumentField) GetRecipientID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RecipientID
}

func (o *DocumentField) GetPage() float64 {
	if o == nil {
		return 0.0
	}
	return o.Page
}

func (o *DocumentField) GetPositionX() any {
	if o == nil {
		return nil
	}
	return o.PositionX
}

func (o *DocumentField) GetPositionY() any {
	if o == nil {
		return nil
	}
	return o.PositionY
}

func (o *DocumentField) GetWidth() any {
	if o == nil {
		return nil
	}
	return o.Width
}

func (o *DocumentField) GetHeight() any {
	if o == nil {
		return nil
	}
	return o.Height
}

func (o *DocumentField) GetCustomText() string {
	if o == nil {
		return ""
	}
	return o.CustomText
}

func (o *DocumentField) GetInserted() bool {
	if o == nil {
		return false
	}
	return o.Inserted
}

func (o *DocumentField) GetFieldMeta() *DocumentFieldMetaUnion {
	if o == nil {
		return nil
	}
	return o.FieldMeta
}

type Document struct {
	Visibility DocumentVisibility                    `json:"visibility"`
	Status     DocumentCreateDocumentTemporaryStatus `json:"status"`
	Source     DocumentCreateDocumentTemporarySource `json:"source"`
	ID         float64                               `json:"id"`
	// A custom external ID you can use to identify the document.
	ExternalID *string `json:"externalId"`
	// The ID of the user that created this document.
	UserID         float64                                      `json:"userId"`
	AuthOptions    *DocumentCreateDocumentTemporaryAuthOptions  `json:"authOptions"`
	FormValues     map[string]DocumentFormValues                `json:"formValues"`
	Title          string                                       `json:"title"`
	DocumentDataID string                                       `json:"documentDataId"`
	CreatedAt      string                                       `json:"createdAt"`
	UpdatedAt      string                                       `json:"updatedAt"`
	CompletedAt    *string                                      `json:"completedAt"`
	DeletedAt      *string                                      `json:"deletedAt"`
	TeamID         *float64                                     `json:"teamId"`
	TemplateID     *float64                                     `json:"templateId"`
	DocumentData   DocumentCreateDocumentTemporaryDocumentData  `json:"documentData"`
	DocumentMeta   *DocumentCreateDocumentTemporaryDocumentMeta `json:"documentMeta"`
	Recipients     []DocumentRecipient                          `json:"recipients"`
	Fields         []DocumentField                              `json:"fields"`
}

func (o *Document) GetVisibility() DocumentVisibility {
	if o == nil {
		return DocumentVisibility("")
	}
	return o.Visibility
}

func (o *Document) GetStatus() DocumentCreateDocumentTemporaryStatus {
	if o == nil {
		return DocumentCreateDocumentTemporaryStatus("")
	}
	return o.Status
}

func (o *Document) GetSource() DocumentCreateDocumentTemporarySource {
	if o == nil {
		return DocumentCreateDocumentTemporarySource("")
	}
	return o.Source
}

func (o *Document) GetID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ID
}

func (o *Document) GetExternalID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalID
}

func (o *Document) GetUserID() float64 {
	if o == nil {
		return 0.0
	}
	return o.UserID
}

func (o *Document) GetAuthOptions() *DocumentCreateDocumentTemporaryAuthOptions {
	if o == nil {
		return nil
	}
	return o.AuthOptions
}

func (o *Document) GetFormValues() map[string]DocumentFormValues {
	if o == nil {
		return nil
	}
	return o.FormValues
}

func (o *Document) GetTitle() string {
	if o == nil {
		return ""
	}
	return o.Title
}

func (o *Document) GetDocumentDataID() string {
	if o == nil {
		return ""
	}
	return o.DocumentDataID
}

func (o *Document) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *Document) GetUpdatedAt() string {
	if o == nil {
		return ""
	}
	return o.UpdatedAt
}

func (o *Document) GetCompletedAt() *string {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *Document) GetDeletedAt() *string {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *Document) GetTeamID() *float64 {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *Document) GetTemplateID() *float64 {
	if o == nil {
		return nil
	}
	return o.TemplateID
}

func (o *Document) GetDocumentData() DocumentCreateDocumentTemporaryDocumentData {
	if o == nil {
		return DocumentCreateDocumentTemporaryDocumentData{}
	}
	return o.DocumentData
}

func (o *Document) GetDocumentMeta() *DocumentCreateDocumentTemporaryDocumentMeta {
	if o == nil {
		return nil
	}
	return o.DocumentMeta
}

func (o *Document) GetRecipients() []DocumentRecipient {
	if o == nil {
		return []DocumentRecipient{}
	}
	return o.Recipients
}

func (o *Document) GetFields() []DocumentField {
	if o == nil {
		return []DocumentField{}
	}
	return o.Fields
}

// DocumentCreateDocumentTemporaryResponseBody - Successful response
type DocumentCreateDocumentTemporaryResponseBody struct {
	Document Document `json:"document"`
	// The URL to upload the document PDF to. Use a PUT request with the file via form-data
	UploadURL string `json:"uploadUrl"`
}

func (o *DocumentCreateDocumentTemporaryResponseBody) GetDocument() Document {
	if o == nil {
		return Document{}
	}
	return o.Document
}

func (o *DocumentCreateDocumentTemporaryResponseBody) GetUploadURL() string {
	if o == nil {
		return ""
	}
	return o.UploadURL
}

type DocumentCreateDocumentTemporaryResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Successful response
	Object *DocumentCreateDocumentTemporaryResponseBody
}

func (o *DocumentCreateDocumentTemporaryResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *DocumentCreateDocumentTemporaryResponse) GetObject() *DocumentCreateDocumentTemporaryResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
